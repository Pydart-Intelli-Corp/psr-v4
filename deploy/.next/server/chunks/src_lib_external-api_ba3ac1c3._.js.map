{"version":3,"sources":["turbopack:///[project]/src/lib/external-api/InputValidator.ts","turbopack:///[project]/src/lib/external-api/QueryBuilder.ts","turbopack:///[project]/src/lib/external-api/ESP32ResponseHelper.ts","turbopack:///[project]/src/lib/external-api/BaseExternalAPI.ts","turbopack:///[project]/src/lib/external-api/index.ts","turbopack:///[project]/src/lib/external-api/ResponseFormatter.ts"],"sourcesContent":["/**\r\n * Utility class for validating and parsing InputString components\r\n */\r\nexport class InputValidator {\r\n  /**\r\n   * Validate and parse society ID (handles S- prefix format)\r\n   */\r\n  static validateSocietyId(societyIdStr: string): { \r\n    isValid: boolean; \r\n    id: string; \r\n    fallback: string; \r\n    numericId?: number;\r\n    error?: string;\r\n  } {\r\n    if (!societyIdStr || (typeof societyIdStr === 'string' && societyIdStr.trim() === '')) {\r\n      return {\r\n        isValid: false,\r\n        id: societyIdStr,\r\n        fallback: societyIdStr,\r\n        error: 'Society ID cannot be empty'\r\n      };\r\n    }\r\n\r\n    // Preserve original format for database lookup\r\n    const id = societyIdStr;\r\n    \r\n    // Extract fallback ID (remove S- prefix if present)\r\n    let fallback = societyIdStr;\r\n    if (societyIdStr.startsWith('S-')) {\r\n      fallback = societyIdStr.substring(2);\r\n    }\r\n\r\n    // Try to parse numeric ID for fallback matching\r\n    let numericId: number | undefined;\r\n    const numericPart = parseInt(fallback);\r\n    if (!isNaN(numericPart)) {\r\n      numericId = numericPart;\r\n    }\r\n\r\n    return {\r\n      isValid: true,\r\n      id,\r\n      fallback,\r\n      numericId\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate and parse machine ID (handles M prefix format with optional letter)\r\n   * \r\n   * Supports multiple formats:\r\n   * - M00001 -> 1 (numeric)\r\n   * - Mm00001 -> m1 (alphanumeric with letter)\r\n   * - Ma00005 -> a5 (alphanumeric with letter)\r\n   * - M0000df -> df (fully alphanumeric)\r\n   * \r\n   * @param machineId - Machine ID with M prefix\r\n   * @returns Validation result with parsed IDs and variants\r\n   */\r\n  static validateMachineId(machineId: string): {\r\n    isValid: boolean;\r\n    numericId?: number;\r\n    alphanumericId?: string;\r\n    withoutPrefix?: string;\r\n    strippedId?: string;\r\n    variants?: (string | number)[];\r\n    isNumeric?: boolean;\r\n    error?: string;\r\n  } {\r\n    if (!machineId || machineId.trim() === '') {\r\n      return {\r\n        isValid: false,\r\n        error: 'Machine ID is required but not provided'\r\n      };\r\n    }\r\n\r\n    // Validate machine ID format (must start with M)\r\n    if (!machineId.startsWith('M') || machineId.length < 2) {\r\n      return {\r\n        isValid: false,\r\n        error: `Invalid machine ID format: \"${machineId}\"`\r\n      };\r\n    }\r\n\r\n    // Remove first 'M' prefix and extract actual machine ID\r\n    // Format: M + optional_letter + numbers\r\n    // Examples: Mm00001 -> m00001, M00001 -> 00001, Ma00005 -> a00005\r\n    const withoutPrefix = machineId.substring(1);\r\n    \r\n    // Validate that remaining part is alphanumeric\r\n    if (!/^[a-zA-Z0-9]+$/.test(withoutPrefix)) {\r\n      return {\r\n        isValid: false,\r\n        error: `Invalid machine ID format: \"${machineId}\" - contains invalid characters`\r\n      };\r\n    }\r\n    \r\n    let processedId: string;\r\n    let isNumeric = false;\r\n    let numericId: number | undefined;\r\n    let alphanumericId: string | undefined;\r\n    \r\n    // Check if withoutPrefix contains any letters\r\n    const hasLetters = /[a-zA-Z]/.test(withoutPrefix);\r\n    \r\n    if (hasLetters) {\r\n      // Contains letters - treat as alphanumeric\r\n      // Examples: m00001, 000m1, 0000df, abc123\r\n      const strippedId = withoutPrefix.replace(/^0+/, '') || withoutPrefix;\r\n      \r\n      // Check if it starts with a letter after removing zeros\r\n      if (/^[a-zA-Z]/.test(strippedId)) {\r\n        const letter = strippedId.charAt(0).toLowerCase();\r\n        const remainingPart = strippedId.substring(1);\r\n        \r\n        // Check if remaining part is numeric\r\n        if (/^\\d+$/.test(remainingPart)) {\r\n          // Letter + numbers: m00001 -> m1, 000m1 -> m1\r\n          const cleanedNumber = remainingPart.replace(/^0+/, '') || '0';\r\n          processedId = letter + cleanedNumber;\r\n          alphanumericId = processedId;\r\n        } else {\r\n          // Mixed alphanumeric: df, abc123\r\n          processedId = strippedId;\r\n          alphanumericId = processedId;\r\n        }\r\n      } else {\r\n        // Starts with number but has letters: should not happen after strip\r\n        processedId = strippedId;\r\n        alphanumericId = processedId;\r\n      }\r\n    } else {\r\n      // No letter, just numbers (e.g., 00001 -> 1)\r\n      processedId = withoutPrefix.replace(/^0+/, '') || '0';\r\n      const parsed = parseInt(processedId);\r\n      \r\n      if (!isNaN(parsed) && parsed > 0) {\r\n        isNumeric = true;\r\n        numericId = parsed;\r\n      } else {\r\n        return {\r\n          isValid: false,\r\n          error: `Invalid machine ID: \"${machineId}\" - invalid numeric format`\r\n        };\r\n      }\r\n    }\r\n\r\n    console.log(`üîÑ Machine ID conversion: \"${machineId}\" -> \"${withoutPrefix}\" -> \"${processedId}\"`);\r\n\r\n    // Create variants for flexible database matching\r\n    const variants: (string | number)[] = [];\r\n    \r\n    if (isNumeric && numericId) {\r\n      // Numeric ID variants\r\n      variants.push(numericId);           // Numeric: 1\r\n      variants.push(machineId);           // Original: M00001\r\n      variants.push(withoutPrefix);       // Without M: 00001\r\n      variants.push(processedId);         // Stripped: 1\r\n      variants.push(String(numericId));   // String numeric: \"1\"\r\n    } else if (alphanumericId) {\r\n      // Alphanumeric ID variants\r\n      variants.push(alphanumericId);      // Processed: m1, df\r\n      variants.push(withoutPrefix);       // Without M: m00001, 0000df\r\n      \r\n      // Add stripped version if different\r\n      const strippedVersion = withoutPrefix.replace(/^0+/, '');\r\n      if (strippedVersion && strippedVersion !== alphanumericId && strippedVersion !== withoutPrefix) {\r\n        variants.push(strippedVersion);\r\n      }\r\n    }\r\n\r\n    return {\r\n      isValid: true,\r\n      numericId,\r\n      alphanumericId,\r\n      withoutPrefix,\r\n      strippedId: processedId,\r\n      variants,\r\n      isNumeric\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate DB Key format\r\n   */\r\n  static validateDbKey(dbKey: string): { isValid: boolean; error?: string } {\r\n    if (!dbKey || dbKey.trim() === '') {\r\n      return {\r\n        isValid: false,\r\n        error: 'DB Key is required'\r\n      };\r\n    }\r\n\r\n    // Add additional DB key format validation if needed\r\n    if (dbKey.length < 2) {\r\n      return {\r\n        isValid: false,\r\n        error: 'DB Key must be at least 2 characters'\r\n      };\r\n    }\r\n\r\n    return { isValid: true };\r\n  }\r\n\r\n  /**\r\n   * Validate machine model/type (basic validation)\r\n   */\r\n  static validateMachineModel(machineModel: string): { \r\n    isValid: boolean; \r\n    warning?: string; \r\n  } {\r\n    if (!machineModel || machineModel.trim() === '') {\r\n      return {\r\n        isValid: true, // Not blocking for now\r\n        warning: `Machine model is empty: \"${machineModel}\"`\r\n      };\r\n    }\r\n\r\n    return { isValid: true };\r\n  }\r\n\r\n  /**\r\n   * Validate password type for machine password endpoints\r\n   */\r\n  static validatePasswordType(passwordType: string): {\r\n    isValid: boolean;\r\n    isUser: boolean;\r\n    isSupervisor: boolean;\r\n    error?: string;\r\n  } {\r\n    if (!passwordType) {\r\n      return {\r\n        isValid: false,\r\n        isUser: false,\r\n        isSupervisor: false,\r\n        error: 'Password type is required'\r\n      };\r\n    }\r\n\r\n    // Accept both full formats (U$0D, S$0D) and short formats (U, S)\r\n    const isUser = passwordType.startsWith('U');\r\n    const isSupervisor = passwordType.startsWith('S');\r\n\r\n    if (!isUser && !isSupervisor) {\r\n      return {\r\n        isValid: false,\r\n        isUser: false,\r\n        isSupervisor: false,\r\n        error: `Invalid password type: \"${passwordType}\"`\r\n      };\r\n    }\r\n\r\n    return {\r\n      isValid: true,\r\n      isUser,\r\n      isSupervisor\r\n    };\r\n  }\r\n}","/**\r\n * Utility class for building database queries for external APIs\r\n */\r\nexport class QueryBuilder {\r\n  /**\r\n   * Build society filter conditions for WHERE clause\r\n   */\r\n  static buildSocietyFilter(\r\n    societyId: string, \r\n    fallbackId: string, \r\n    numericId?: number\r\n  ): {\r\n    condition: string;\r\n    replacements: (string | number)[];\r\n  } {\r\n    // Support multiple society ID formats:\r\n    // 1. String matching (s.society_id = 'S-s12')\r\n    // 2. Fallback string matching (s.society_id = 's12') \r\n    // 3. Numeric matching (m.society_id = 12)\r\n    \r\n    const condition = '(s.society_id = ? OR s.society_id = ? OR m.society_id = ?)';\r\n    const societyIdNumeric = numericId || fallbackId;\r\n    \r\n    return {\r\n      condition,\r\n      replacements: [societyId, fallbackId, societyIdNumeric]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build machine filter conditions for WHERE clause\r\n   * Supports both numeric and alphanumeric machine IDs\r\n   * \r\n   * @param machineValidation - Result from InputValidator.validateMachineId()\r\n   * @param useNumericId - Whether to use numeric ID (m.id) or string ID (m.machine_id)\r\n   */\r\n  static buildMachineFilter(\r\n    machineValidation: {\r\n      numericId?: number;\r\n      alphanumericId?: string;\r\n      variants?: (string | number)[];\r\n      isNumeric?: boolean;\r\n    },\r\n    useNumericId: boolean = true\r\n  ): {\r\n    condition: string;\r\n    replacements: (string | number)[];\r\n  } {\r\n    // For numeric machine IDs (backward compatibility)\r\n    if (machineValidation.isNumeric && machineValidation.numericId && useNumericId) {\r\n      // Direct numeric ID matching: m.id = 1\r\n      return {\r\n        condition: 'm.id = ?',\r\n        replacements: [machineValidation.numericId]\r\n      };\r\n    }\r\n    \r\n    // For alphanumeric machine IDs or string-based matching\r\n    if (machineValidation.variants && machineValidation.variants.length > 0) {\r\n      // Use IN clause with all variants\r\n      const placeholders = machineValidation.variants.map(() => '?').join(', ');\r\n      \r\n      return {\r\n        condition: `m.machine_id IN (${placeholders})`,\r\n        replacements: machineValidation.variants\r\n      };\r\n    }\r\n\r\n    // Fallback to direct alphanumeric matching\r\n    if (machineValidation.alphanumericId) {\r\n      return {\r\n        condition: 'm.machine_id = ?',\r\n        replacements: [machineValidation.alphanumericId]\r\n      };\r\n    }\r\n\r\n    // Final fallback - should not reach here if validation passed\r\n    throw new Error('Invalid machine validation result for query building');\r\n  }\r\n\r\n  /**\r\n   * Build base query with schema, table, and joins\r\n   */\r\n  static buildBaseQuery(schemaName: string, tableName: string): string {\r\n    const escapedSchema = QueryBuilder.escapeIdentifier(schemaName);\r\n    \r\n    if (tableName === 'farmers') {\r\n      return `\r\n        FROM ${escapedSchema}.farmers f\r\n        LEFT JOIN ${escapedSchema}.societies s ON f.society_id = s.id\r\n        LEFT JOIN ${escapedSchema}.machines m ON f.machine_id = m.id\r\n      `;\r\n    } else if (tableName === 'machines') {\r\n      return `\r\n        FROM ${escapedSchema}.machines m\r\n        LEFT JOIN ${escapedSchema}.societies s ON m.society_id = s.id\r\n      `;\r\n    } else {\r\n      throw new Error(`Unsupported table name: ${tableName}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build complete SELECT query for farmer info\r\n   */\r\n  static buildFarmerQuery(\r\n    schemaName: string,\r\n    societyFilter: ReturnType<typeof QueryBuilder.buildSocietyFilter>,\r\n    machineFilter: ReturnType<typeof QueryBuilder.buildMachineFilter>,\r\n    pagination?: { limit: number; offset: number }\r\n  ): {\r\n    query: string;\r\n    replacements: (string | number)[];\r\n  } {\r\n    const baseQuery = QueryBuilder.buildBaseQuery(schemaName, 'farmers');\r\n    \r\n    let query = `\r\n      SELECT \r\n        f.id, \r\n        f.farmer_id,\r\n        f.rf_id, \r\n        f.name, \r\n        f.phone, \r\n        f.sms_enabled, \r\n        f.bonus\r\n      ${baseQuery}\r\n      WHERE ${societyFilter.condition}\r\n        AND f.status = 'active'\r\n        AND ${machineFilter.condition}\r\n      ORDER BY f.farmer_id\r\n    `;\r\n\r\n    let replacements = [\r\n      ...societyFilter.replacements,\r\n      ...machineFilter.replacements\r\n    ];\r\n\r\n    if (pagination) {\r\n      query += ' LIMIT ? OFFSET ?';\r\n      replacements = [...replacements, pagination.limit, pagination.offset];\r\n    }\r\n\r\n    return { query, replacements };\r\n  }\r\n\r\n  /**\r\n   * Build complete SELECT query for machine password\r\n   */\r\n  static buildMachinePasswordQuery(\r\n    schemaName: string,\r\n    societyFilter: ReturnType<typeof QueryBuilder.buildSocietyFilter>,\r\n    machineFilter: ReturnType<typeof QueryBuilder.buildMachineFilter>\r\n  ): {\r\n    query: string;\r\n    replacements: (string | number)[];\r\n  } {\r\n    const baseQuery = QueryBuilder.buildBaseQuery(schemaName, 'machines');\r\n    \r\n    const query = `\r\n      SELECT \r\n        m.id, \r\n        m.machine_id, \r\n        m.user_password, \r\n        m.supervisor_password, \r\n        m.statusU, \r\n        m.statusS,\r\n        s.society_id as society_string_id\r\n      ${baseQuery}\r\n      WHERE ${societyFilter.condition}\r\n        AND ${machineFilter.condition}\r\n        AND m.status = 'active'\r\n    `;\r\n\r\n    const replacements = [\r\n      ...societyFilter.replacements,\r\n      ...machineFilter.replacements\r\n    ];\r\n\r\n    return { query, replacements };\r\n  }\r\n\r\n  /**\r\n   * Build society lookup query to get database ID from society_id string\r\n   */\r\n  static buildSocietyLookupQuery(\r\n    schemaName: string,\r\n    societyIdStr: string\r\n  ): {\r\n    query: string;\r\n    replacements: string[];\r\n  } {\r\n    const escapedSchema = QueryBuilder.escapeIdentifier(schemaName);\r\n    \r\n    // Try both with and without S- prefix\r\n    const lookupParams = societyIdStr.startsWith('S-') \r\n      ? [societyIdStr, societyIdStr.substring(2)]\r\n      : [`S-${societyIdStr}`, societyIdStr];\r\n    \r\n    const query = `\r\n      SELECT id FROM ${escapedSchema}.societies \r\n      WHERE society_id = ? OR society_id = ?\r\n      LIMIT 1\r\n    `;\r\n\r\n    return {\r\n      query,\r\n      replacements: lookupParams\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Safely escape database identifiers (schema/table names)\r\n   */\r\n  static escapeIdentifier(identifier: string): string {\r\n    // Remove any non-alphanumeric characters except underscores\r\n    const cleaned = identifier.replace(/[^a-zA-Z0-9_]/g, '');\r\n    return `\\`${cleaned}\\``;\r\n  }\r\n\r\n  /**\r\n   * Build pagination parameters\r\n   */\r\n  static buildPagination(pageNumber: number, pageSize: number = 5): {\r\n    limit: number;\r\n    offset: number;\r\n    pageNumber: number;\r\n  } {\r\n    const normalizedPageNumber = Math.max(1, pageNumber);\r\n    const offset = (normalizedPageNumber - 1) * pageSize;\r\n    \r\n    return {\r\n      limit: pageSize,\r\n      offset,\r\n      pageNumber: normalizedPageNumber\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract page number from C parameter format (C00001 = page 1, C00002 = page 2)\r\n   */\r\n  static parsePageNumber(lengthParam: string): number {\r\n    if (!lengthParam || !lengthParam.startsWith('C')) {\r\n      return 1;\r\n    }\r\n    \r\n    const pageNumber = parseInt(lengthParam.replace(/^C0*/, '')) || 1;\r\n    return Math.max(1, pageNumber);\r\n  }\r\n}","/**\r\n * ESP32-Friendly Response Helper\r\n * \r\n * Utilities for creating responses compatible with ESP32 WiFi modules\r\n * \r\n * Key Requirements:\r\n * - Always return HTTP 200 status (even for errors)\r\n * - No quotes around response text for simple messages\r\n * - Specific headers: charset=utf-8, Content-Length, Connection: close\r\n * - Cache-Control: no-cache for fresh data\r\n */\r\n\r\nexport class ESP32ResponseHelper {\r\n  /**\r\n   * Create ESP32-friendly success response\r\n   * @param data - Response data (will be quoted by default)\r\n   * @param options - Additional options\r\n   */\r\n  static createResponse(\r\n    data: string, \r\n    options?: {\r\n      contentType?: string;\r\n      addQuotes?: boolean;\r\n      additionalHeaders?: Record<string, string>;\r\n    }\r\n  ): Response {\r\n    const { \r\n      contentType = 'text/plain; charset=utf-8',\r\n      addQuotes = true, // Changed default to true\r\n      additionalHeaders = {}\r\n    } = options || {};\r\n\r\n    // Wrap response in double quotes by default for ESP32 compatibility\r\n    const responseBody = addQuotes ? `\"${data}\"` : data;\r\n    const contentLength = Buffer.byteLength(responseBody, 'utf8');\r\n\r\n    return new Response(responseBody, {\r\n      status: 200, // Always 200 for ESP32 compatibility\r\n      headers: {\r\n        'Content-Type': contentType,\r\n        'Content-Length': contentLength.toString(),\r\n        'Connection': 'close',\r\n        'Cache-Control': 'no-cache',\r\n        'Access-Control-Allow-Origin': '*',\r\n        ...additionalHeaders\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create ESP32-friendly error response (still returns 200 status)\r\n   */\r\n  static createErrorResponse(errorMessage: string): Response {\r\n    return ESP32ResponseHelper.createResponse(errorMessage);\r\n  }\r\n\r\n  /**\r\n   * Create success response with structured data (pipe-delimited format)\r\n   */\r\n  static createDataResponse(data: string): Response {\r\n    return ESP32ResponseHelper.createResponse(data, {\r\n      additionalHeaders: {\r\n        'Access-Control-Allow-Methods': 'GET, POST',\r\n        'Access-Control-Allow-Headers': 'Content-Type'\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create CSV response with proper headers\r\n   */\r\n  static createCSVResponse(csvData: string, filename: string = 'data.csv'): Response {\r\n    return new Response(csvData, {\r\n      status: 200,\r\n      headers: {\r\n        'Content-Type': 'text/csv; charset=utf-8',\r\n        'Content-Disposition': `attachment; filename=\"${filename}\"`,\r\n        'Content-Length': Buffer.byteLength(csvData, 'utf8').toString(),\r\n        'Connection': 'close',\r\n        'Access-Control-Allow-Origin': '*',\r\n        'Access-Control-Allow-Methods': 'GET, POST',\r\n        'Access-Control-Allow-Headers': 'Content-Type'\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create CORS preflight response\r\n   */\r\n  static createCORSResponse(): Response {\r\n    return new Response(null, {\r\n      status: 200,\r\n      headers: {\r\n        'Access-Control-Allow-Origin': '*',\r\n        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\r\n        'Access-Control-Allow-Headers': 'Content-Type',\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Extract InputString from request (handles malformed URLs from ESP32)\r\n   */\r\n  static async extractInputString(request: Request): Promise<string | null> {\r\n    let inputString: string | null = null;\r\n\r\n    if (request.method === 'GET') {\r\n      const { searchParams } = new URL(request.url);\r\n      inputString = searchParams.get('InputString');\r\n\r\n      // Handle malformed URLs from ESP32 (e.g., \"?,InputString=...\")\r\n      if (!inputString) {\r\n        // Check if any param key contains \"InputString\" (handles \",InputString\" case)\r\n        for (const [key, value] of searchParams.entries()) {\r\n          if (key.includes('InputString')) {\r\n            inputString = value;\r\n            console.log(`   ‚úÖ ESP32: Found InputString in malformed param key: \"${key}\"`);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    } else if (request.method === 'POST') {\r\n      try {\r\n        const body = await request.json();\r\n        inputString = body.InputString || null;\r\n      } catch {\r\n        try {\r\n          const formData = await request.formData();\r\n          inputString = formData.get('InputString') as string || null;\r\n        } catch (error) {\r\n          console.log(`‚ùå ESP32: Failed to parse POST body:`, error);\r\n        }\r\n      }\r\n    }\r\n\r\n    return inputString;\r\n  }\r\n\r\n  /**\r\n   * Filter line ending characters from InputString\r\n   * ESP32 sends $0D, $0A, $0D$0A patterns\r\n   */\r\n  static filterLineEndings(inputString: string): string {\r\n    if (!inputString) return inputString;\r\n\r\n    const original = inputString;\r\n    \r\n    // Remove common line ending patterns\r\n    const filtered = inputString\r\n      .replace(/\\$0D\\$0A/g, '')  // CRLF\r\n      .replace(/\\$0D/g, '')      // CR\r\n      .replace(/\\$0A/g, '')      // LF\r\n      .replace(/\\r\\n/g, '')      // Actual CRLF\r\n      .replace(/\\r/g, '')        // Actual CR\r\n      .replace(/\\n/g, '');       // Actual LF\r\n    \r\n    if (original !== filtered) {\r\n      console.log(`üßπ ESP32: Filtered line endings: \"${original}\" -> \"${filtered}\"`);\r\n    }\r\n\r\n    return filtered;\r\n  }\r\n\r\n  /**\r\n   * Log ESP32 request details for debugging\r\n   */\r\n  static logRequest(request: Request, dbKey: string, inputString: string | null): void {\r\n    console.log(`\\n${'='.repeat(80)}`);\r\n    console.log(`üì° ESP32 External API Request:`);\r\n    console.log(`   Timestamp: ${new Date().toISOString()}`);\r\n    console.log(`   Method: ${request.method}`);\r\n    console.log(`   Full URL: ${request.url}`);\r\n    console.log(`   DB Key: \"${dbKey}\"`);\r\n    console.log(`   InputString: \"${inputString}\"`);\r\n    console.log(`   Headers:`, {\r\n      'user-agent': request.headers.get('user-agent'),\r\n      'content-type': request.headers.get('content-type'),\r\n      'connection': request.headers.get('connection'),\r\n      'host': request.headers.get('host')\r\n    });\r\n    console.log(`${'='.repeat(80)}\\n`);\r\n  }\r\n}\r\n","import { NextRequest } from 'next/server';\r\n\r\n/**\r\n * Base input structure for all external API endpoints\r\n */\r\nexport interface BaseInputParts {\r\n  societyId: string;\r\n  machineType: string;\r\n  version: string;\r\n  machineId: string;\r\n}\r\n\r\n/**\r\n * Validation result interface\r\n */\r\nexport interface ValidationResult {\r\n  isValid: boolean;\r\n  error?: string;\r\n  parsedSocietyId?: string;\r\n  parsedMachineId?: number;\r\n}\r\n\r\n/**\r\n * Configuration interface for external API endpoints\r\n */\r\nexport interface ExternalAPIConfig {\r\n  endpointName: string;\r\n  requiresExactPartCount?: boolean;\r\n  expectedPartCounts: number[];\r\n  filterLineEndings: boolean;\r\n  standardErrorMessage: string;\r\n}\r\n\r\n/**\r\n * Abstract base class for external API endpoints following InputString pattern\r\n */\r\nexport abstract class BaseExternalAPI<TInput extends BaseInputParts, TResult> {\r\n  protected config: ExternalAPIConfig;\r\n\r\n  constructor(config: ExternalAPIConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  /**\r\n   * Parse InputString into typed input structure\r\n   */\r\n  abstract parseInput(inputString: string): TInput | null;\r\n\r\n  /**\r\n   * Validate parsed input parts\r\n   */\r\n  abstract validateInput(input: TInput, dbKey: string): Promise<ValidationResult>;\r\n\r\n  /**\r\n   * Execute the main business logic\r\n   */\r\n  abstract executeBusinessLogic(input: TInput, schemaName: string, sequelize: unknown): Promise<TResult>;\r\n\r\n  /**\r\n   * Format the result into response string\r\n   */\r\n  abstract formatResponse(result: TResult): string;\r\n\r\n  /**\r\n   * Get error message for this endpoint\r\n   */\r\n  getErrorMessage(): string {\r\n    return this.config.standardErrorMessage;\r\n  }\r\n\r\n  /**\r\n   * Main request handler - implements common flow\r\n   */\r\n  async handleRequest(\r\n    request: NextRequest,\r\n    { params }: { params: Promise<Record<string, string>> }\r\n  ): Promise<Response> {\r\n    try {\r\n      // Step 1: Extract InputString from GET/POST\r\n      let inputString = await this.extractInputString(request);\r\n      \r\n      // Step 2: Resolve dynamic params\r\n      const resolvedParams = await params;\r\n      const dbKey = resolvedParams['db-key'] || resolvedParams.dbKey || resolvedParams['dbkey'];\r\n\r\n      this.logRequest(request, dbKey, inputString);\r\n\r\n      // Step 3: Filter line endings if configured\r\n      if (this.config.filterLineEndings && inputString) {\r\n        inputString = this.filterLineEndings(inputString);\r\n      }\r\n\r\n      // Step 4: Basic validation\r\n      if (!this.validateBasicInputs(dbKey, inputString)) {\r\n        return this.errorResponse();\r\n      }\r\n\r\n      // Step 5: Parse InputString\r\n      const parsedInput = this.parseInput(inputString!);\r\n      if (!parsedInput) {\r\n        console.log(`‚ùå ${this.config.endpointName}: Failed to parse InputString: \"${inputString}\"`);\r\n        return this.errorResponse();\r\n      }\r\n\r\n      // Step 6: Connect to database and validate\r\n      const { sequelize, schemaName } = await this.connectAndValidate(dbKey);\r\n      if (!sequelize || !schemaName) {\r\n        return this.errorResponse();\r\n      }\r\n\r\n      // Step 7: Validate parsed input\r\n      const validation = await this.validateInput(parsedInput, dbKey);\r\n      if (!validation.isValid) {\r\n        console.log(`‚ùå ${this.config.endpointName}: Input validation failed: ${validation.error}`);\r\n        return this.errorResponse();\r\n      }\r\n\r\n      // Step 8: Execute business logic\r\n      const result = await this.executeBusinessLogic(parsedInput, schemaName, sequelize);\r\n\r\n      // Step 9: Format and return response\r\n      const formattedResponse = this.formatResponse(result);\r\n      return this.successResponse(formattedResponse);\r\n\r\n    } catch (error) {\r\n      console.error(`‚ùå Error in ${this.config.endpointName} API:`, error);\r\n      return this.errorResponse();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract InputString from request (GET query param or POST body)\r\n   */\r\n  private async extractInputString(request: NextRequest): Promise<string | null> {\r\n    let inputString: string | null = null;\r\n    \r\n    if (request.method === 'GET') {\r\n      const { searchParams } = new URL(request.url);\r\n      inputString = searchParams.get('InputString');\r\n    } else if (request.method === 'POST') {\r\n      try {\r\n        const body = await request.json();\r\n        inputString = body.InputString || null;\r\n      } catch (error) {\r\n        try {\r\n          const formData = await request.formData();\r\n          inputString = formData.get('InputString') as string || null;\r\n        } catch {\r\n          console.log(`‚ùå Failed to parse POST body:`, error);\r\n        }\r\n      }\r\n    }\r\n    \r\n    return inputString;\r\n  }\r\n\r\n  /**\r\n   * Filter line ending characters from InputString\r\n   */\r\n  private filterLineEndings(inputString: string): string {\r\n    const originalInputString = inputString;\r\n    \r\n    // Remove common line ending patterns: $0D (CR), $0A (LF), $0D$0A (CRLF)\r\n    const filtered = inputString\r\n      .replace(/\\$0D\\$0A/g, '')  // Remove $0D$0A (CRLF)\r\n      .replace(/\\$0D/g, '')      // Remove $0D (CR) \r\n      .replace(/\\$0A/g, '')      // Remove $0A (LF)\r\n      .replace(/\\r\\n/g, '')      // Remove actual CRLF characters\r\n      .replace(/\\r/g, '')        // Remove actual CR characters\r\n      .replace(/\\n/g, '');       // Remove actual LF characters\r\n    \r\n    if (originalInputString !== filtered) {\r\n      console.log(`üßπ ${this.config.endpointName}: Filtered line endings: \"${originalInputString}\" -> \"${filtered}\"`);\r\n    }\r\n    \r\n    return filtered;\r\n  }\r\n\r\n  /**\r\n   * Basic input validation\r\n   */\r\n  private validateBasicInputs(dbKey: string, inputString: string | null): boolean {\r\n    if (!dbKey || dbKey.trim() === '') {\r\n      console.log(`‚ùå ${this.config.endpointName}: DB Key validation failed - dbKey: \"${dbKey}\"`);\r\n      return false;\r\n    }\r\n\r\n    if (!inputString) {\r\n      console.log(`‚ùå ${this.config.endpointName}: InputString is required`);\r\n      return false;\r\n    }\r\n\r\n    // Validate InputString part count\r\n    const parts = inputString.split('|');\r\n    if (!this.config.expectedPartCounts.includes(parts.length)) {\r\n      console.log(`‚ùå ${this.config.endpointName}: Invalid InputString part count. Expected: ${this.config.expectedPartCounts.join(' or ')}, Got: ${parts.length}`);\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Connect to database and get admin schema\r\n   */\r\n  private async connectAndValidate(dbKey: string): Promise<{ sequelize: unknown, schemaName: string | null }> {\r\n    try {\r\n      const { connectDB } = await import('@/lib/database');\r\n      await connectDB();\r\n      \r\n      const { getModels } = await import('@/models');\r\n      const { sequelize, User } = getModels();\r\n\r\n      // Find admin by dbKey to get schema name\r\n      const admin = await User.findOne({ \r\n        where: { dbKey: dbKey.toUpperCase() } \r\n      });\r\n\r\n      if (!admin || !admin.dbKey) {\r\n        console.log(`‚ùå ${this.config.endpointName}: Admin not found or missing DB Key for: ${dbKey}`);\r\n        return { sequelize: null, schemaName: null };\r\n      }\r\n\r\n      // Generate admin-specific schema name\r\n      const cleanAdminName = admin.fullName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\r\n      const schemaName = `${cleanAdminName}_${admin.dbKey.toLowerCase()}`;\r\n\r\n      console.log(`‚úÖ ${this.config.endpointName}: Using schema: ${schemaName}`);\r\n      \r\n      return { sequelize, schemaName };\r\n    } catch (error) {\r\n      console.error(`‚ùå ${this.config.endpointName}: Database connection failed:`, error);\r\n      return { sequelize: null, schemaName: null };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log request details\r\n   */\r\n  private logRequest(request: NextRequest, dbKey: string, inputString: string | null): void {\r\n    console.log(`üîç ${this.config.endpointName} External API Request - Full URL: ${request.url}`);\r\n    console.log(`üîç DB Key: \"${dbKey}\", InputString: \"${inputString}\"`);\r\n    console.log(`üîç DB Key type: ${typeof dbKey}, length: ${dbKey?.length}`);\r\n  }\r\n\r\n  /**\r\n   * Create success response\r\n   */\r\n  protected successResponse(data: string, additionalHeaders?: Record<string, string>): Response {\r\n    return new Response(`\"${data}\"`, {\r\n      status: 200,\r\n      headers: {\r\n        'Content-Type': 'text/plain',\r\n        'Access-Control-Allow-Origin': '*',\r\n        'Access-Control-Allow-Methods': 'GET, POST',\r\n        'Access-Control-Allow-Headers': 'Content-Type',\r\n        ...additionalHeaders\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create error response\r\n   */\r\n  protected errorResponse(): Response {\r\n    return new Response(`\"${this.getErrorMessage()}\"`, {\r\n      status: 200,\r\n      headers: { 'Content-Type': 'text/plain' }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle OPTIONS request for CORS\r\n   */\r\n  async handleOptions(): Promise<Response> {\r\n    return new Response(null, {\r\n      status: 200,\r\n      headers: {\r\n        'Access-Control-Allow-Origin': '*',\r\n        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\r\n        'Access-Control-Allow-Headers': 'Content-Type',\r\n      },\r\n    });\r\n  }\r\n}","// External API pattern base classes and utilities\r\nexport { BaseExternalAPI } from './BaseExternalAPI';\r\nexport type { \r\n  BaseInputParts, \r\n  ValidationResult, \r\n  ExternalAPIConfig \r\n} from './BaseExternalAPI';\r\n\r\n// Input validation utilities\r\nexport { InputValidator } from './InputValidator';\r\n\r\n// Database query building utilities\r\nexport { QueryBuilder } from './QueryBuilder';\r\n\r\n// Response formatting utilities  \r\nexport { ResponseFormatter } from './ResponseFormatter';\r\n\r\n// ESP32-specific response utilities\r\nexport { ESP32ResponseHelper } from './ESP32ResponseHelper';\r\n\r\n// Re-import for interface extension\r\nimport type { BaseInputParts } from './BaseExternalAPI';\r\n\r\n// Common interfaces for external APIs\r\nexport interface FarmerInfoInput extends BaseInputParts {\r\n  pageNumber?: string; // Optional 5th part for pagination\r\n}\r\n\r\nexport interface MachinePasswordInput extends BaseInputParts {\r\n  passwordType: string; // Required 5th part for password type\r\n}\r\n\r\nexport interface MachineUpdateInput extends BaseInputParts {\r\n  datetime?: string; // Optional datetime parameter\r\n}\r\n\r\nexport interface MachineCorrectionInput extends BaseInputParts {\r\n  // Standard 4 parts only (societyId, machineType, version, machineId)\r\n  _marker?: never; // Type marker to prevent linting error\r\n}\r\n\r\nexport interface FarmerResult {\r\n  id: number;\r\n  farmer_id: string;\r\n  rf_id: string;\r\n  name: string;\r\n  phone: string | null;\r\n  sms_enabled: 'ON' | 'OFF' | null;\r\n  bonus: number | null;\r\n}\r\n\r\nexport interface MachinePasswordResult {\r\n  id: number;\r\n  machine_id: string;\r\n  user_password: string | null;\r\n  supervisor_password: string | null;\r\n  statusU: number;\r\n  statusS: number;\r\n  society_string_id?: string;\r\n}\r\n\r\nexport interface MachineCorrectionResult {\r\n  id: number;\r\n  machine_id: number;\r\n  channel1_fat: number;\r\n  channel1_snf: number;\r\n  channel1_clr: number;\r\n  channel1_temp: number;\r\n  channel1_water: number;\r\n  channel1_protein: number;\r\n  channel2_fat: number;\r\n  channel2_snf: number;\r\n  channel2_clr: number;\r\n  channel2_temp: number;\r\n  channel2_water: number;\r\n  channel2_protein: number;\r\n  channel3_fat: number;\r\n  channel3_snf: number;\r\n  channel3_clr: number;\r\n  channel3_temp: number;\r\n  channel3_water: number;\r\n  channel3_protein: number;\r\n  status: number;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}","/**\r\n * Response formatting utilities for external APIs\r\n */\r\nexport class ResponseFormatter {\r\n  /**\r\n   * Format farmer data for CSV download\r\n   */\r\n  static formatFarmerCSV(farmers: Array<{\r\n    id: number;\r\n    farmer_id: string;\r\n    name: string;\r\n    phone: string | null;\r\n    sms_enabled: 'ON' | 'OFF' | null;\r\n    bonus: number | null;\r\n  }>): string {\r\n    const csvHeader = 'ID,RF-ID,NAME,MOBILE,SMS,BONUS\\n';\r\n    \r\n    const csvData = farmers.map(farmer => {\r\n      const phone = farmer.phone || '';\r\n      const smsEnabled = farmer.sms_enabled || 'OFF';\r\n      \r\n      // Convert bonus to number and format without decimal places (matching sample format)\r\n      let bonus = '0';\r\n      if (farmer.bonus !== null && farmer.bonus !== undefined) {\r\n        const bonusNum = Number(farmer.bonus);\r\n        bonus = isNaN(bonusNum) ? '0' : Math.round(bonusNum).toString();\r\n      }\r\n      \r\n      // Escape CSV values that contain commas or quotes\r\n      const escapeCsv = (value: string) => {\r\n        if (value.includes(',') || value.includes('\"')) {\r\n          return `\"${value.replace(/\"/g, '\"\"')}\"`;\r\n        }\r\n        return value;\r\n      };\r\n      \r\n      return `${farmer.id},${escapeCsv(farmer.farmer_id)},${escapeCsv(farmer.name)},${escapeCsv(phone)},${smsEnabled},${bonus}`;\r\n    }).join('\\n');\r\n\r\n    return csvHeader + csvData;\r\n  }\r\n\r\n  /**\r\n   * Format farmer data for pagination response (pipe-delimited)\r\n   */\r\n  static formatFarmerPagination(farmers: Array<{\r\n    id: number;\r\n    farmer_id: string;\r\n    name: string;\r\n    phone: string | null;\r\n    sms_enabled: 'ON' | 'OFF' | null;\r\n    bonus: number | null;\r\n  }>): string {\r\n    // Format: id|farmer_id|name|phone|sms_enabled|bonus||\r\n    // Each farmer separated by ||, fields separated by |\r\n    const responseData = farmers.map(farmer => {\r\n      const phone = farmer.phone || '';\r\n      const smsEnabled = farmer.sms_enabled || 'OFF';\r\n      \r\n      // Convert bonus to number and format with 2 decimal places\r\n      let bonus = '0.00';\r\n      if (farmer.bonus !== null && farmer.bonus !== undefined) {\r\n        const bonusNum = Number(farmer.bonus);\r\n        bonus = isNaN(bonusNum) ? '0.00' : bonusNum.toFixed(2);\r\n      }\r\n      \r\n      return `${farmer.id}|${farmer.farmer_id}|${farmer.name}|${phone}|${smsEnabled}|${bonus}`;\r\n    }).join('||');\r\n\r\n    return responseData;\r\n  }\r\n\r\n  /**\r\n   * Format machine password response\r\n   */\r\n  static formatMachinePassword(\r\n    passwordType: { isUser: boolean; isSupervisor: boolean },\r\n    password: string\r\n  ): string {\r\n    if (passwordType.isUser) {\r\n      return `PU|${password}`;\r\n    } else if (passwordType.isSupervisor) {\r\n      return `PS|${password}`;\r\n    }\r\n    \r\n    throw new Error('Invalid password type for formatting');\r\n  }\r\n\r\n  /**\r\n   * Create standard success response with proper headers\r\n   */\r\n  static createSuccessResponse(\r\n    data: string, \r\n    contentType: 'text/plain' | 'text/csv' = 'text/plain',\r\n    additionalHeaders?: Record<string, string>\r\n  ): Response {\r\n    const headers: Record<string, string> = {\r\n      'Content-Type': contentType,\r\n      'Access-Control-Allow-Origin': '*',\r\n      'Access-Control-Allow-Methods': 'GET, POST',\r\n      'Access-Control-Allow-Headers': 'Content-Type',\r\n      ...additionalHeaders\r\n    };\r\n\r\n    // Add CSV-specific headers\r\n    if (contentType === 'text/csv') {\r\n      headers['Content-Disposition'] = 'attachment; filename=\"FarmerDetails.csv\"';\r\n    }\r\n\r\n    return new Response(`\"${data}\"`, {\r\n      status: 200,\r\n      headers\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create standard error response\r\n   */\r\n  static createErrorResponse(errorMessage: string): Response {\r\n    return new Response(`\"${errorMessage}\"`, {\r\n      status: 200,\r\n      headers: { 'Content-Type': 'text/plain' }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create CORS preflight response\r\n   */\r\n  static createCORSResponse(): Response {\r\n    return new Response(null, {\r\n      status: 200,\r\n      headers: {\r\n        'Access-Control-Allow-Origin': '*',\r\n        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\r\n        'Access-Control-Allow-Headers': 'Content-Type',\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Wrap response data in quotes (external API standard)\r\n   */\r\n  static wrapInQuotes(data: string): string {\r\n    return `\"${data}\"`;\r\n  }\r\n\r\n  /**\r\n   * Log response details for debugging\r\n   */\r\n  static logResponse(\r\n    endpointName: string,\r\n    dataType: string,\r\n    itemCount: number,\r\n    responsePreview?: string\r\n  ): void {\r\n    console.log(`üì§ ${endpointName}: Returning ${dataType} for ${itemCount} items`);\r\n    \r\n    if (responsePreview) {\r\n      const preview = responsePreview.length > 100 \r\n        ? `${responsePreview.substring(0, 100)}...` \r\n        : responsePreview;\r\n      console.log(`üì§ Response preview: ${preview}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log CSV response details\r\n   */\r\n  static logCSVResponse(endpointName: string, itemCount: number, csvSize: number): void {\r\n    console.log(`üìÅ ${endpointName}: Returning CSV data for ${itemCount} items`);\r\n    console.log(`üìÅ CSV size: ${csvSize} characters`);\r\n  }\r\n}"],"names":[],"mappings":"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"}