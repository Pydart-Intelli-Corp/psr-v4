module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/timers [external] (timers, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("timers", () => require("timers"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/process [external] (process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[project]/src/lib/database.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "connectDB",
    ()=>connectDB,
    "createAdminSchema",
    ()=>createAdminSchema,
    "default",
    ()=>__TURBOPACK__default__export__,
    "getAdminConnection",
    ()=>getAdminConnection,
    "initDatabase",
    ()=>initDatabase,
    "testConnection",
    ()=>testConnection
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sequelize/lib/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mysql2/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
;
// Database configuration for Azure MySQL
let sequelize = null;
const createSequelizeInstance = ()=>{
    if (!sequelize) {
        // Don't initialize during build time
        if ("TURBOPACK compile-time truthy", 1) {
            // Determine SSL configuration based on environment
            // Only use SSL if DB_SSL_CA is explicitly set and not empty
            const sslConfig = process.env.DB_SSL_CA && process.env.DB_SSL_CA.trim() !== '' ? {
                require: true,
                rejectUnauthorized: process.env.DB_REJECT_UNAUTHORIZED !== 'false',
                ca: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), process.env.DB_SSL_CA)
            } : ("TURBOPACK compile-time value", "development") === 'production' && process.env.DB_HOST?.includes('azure') ? "TURBOPACK unreachable" : false;
            sequelize = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Sequelize"](process.env.DB_NAME || 'psr_v4_main', process.env.DB_USER || 'psr_admin', process.env.DB_PASSWORD || 'Access@404', {
                host: process.env.DB_HOST || 'localhost',
                port: parseInt(process.env.DB_PORT || '3306'),
                dialect: 'mysql',
                dialectModule: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
                timezone: '+05:30',
                dialectOptions: {
                    ssl: sslConfig,
                    connectTimeout: parseInt(process.env.DB_CONNECTION_TIMEOUT || '30') * 1000
                },
                pool: {
                    max: parseInt(process.env.DB_POOL_MAX || '10'),
                    min: parseInt(process.env.DB_POOL_MIN || '0'),
                    acquire: parseInt(process.env.DB_CONNECTION_TIMEOUT || '30') * 1000,
                    idle: parseInt(process.env.DB_CONNECTION_LIFETIME || '300') * 1000
                },
                logging: ("TURBOPACK compile-time truthy", 1) ? console.log : "TURBOPACK unreachable",
                benchmark: ("TURBOPACK compile-time value", "development") === 'development'
            });
        }
    }
    return sequelize;
};
const testConnection = async ()=>{
    try {
        const db = createSequelizeInstance();
        if (!db) {
            console.error('âŒ Database not initialized');
            return false;
        }
        await db.authenticate();
        console.log('âœ… Database connection established successfully.');
        return true;
    } catch (error) {
        console.error('âŒ Unable to connect to the database:', error);
        return false;
    }
};
const initDatabase = async (useMigrations = false)=>{
    try {
        const db = createSequelizeInstance();
        if (!db) {
            console.error('âŒ Database not initialized');
            return false;
        }
        if (useMigrations) {
            // Use migrations instead of sync for production
            const { migrationRunner } = await __turbopack_context__.A("[project]/src/lib/migrations.ts [app-route] (ecmascript, async loader)");
            await migrationRunner.initializeDatabase();
        } else {
            // Development mode - use sync
            await db.sync({
                alter: ("TURBOPACK compile-time value", "development") === 'development'
            });
        }
        console.log('âœ… Database synchronized successfully.');
        return true;
    } catch (error) {
        console.error('âŒ Database synchronization failed:', error);
        return false;
    }
};
const connectDB = async ()=>{
    try {
        const db = createSequelizeInstance();
        if (!db) {
            throw new Error('Database not initialized');
        }
        await db.authenticate();
        return db;
    } catch (error) {
        console.error('âŒ Database connection failed:', error);
        throw error;
    }
};
const createAdminSchema = async (adminEmail)=>{
    try {
        // Generate DB key: db-<first 3 letters of email><3 random numbers>
        const emailPrefix = adminEmail.substring(0, 3).toLowerCase();
        const randomSuffix = Math.floor(100 + Math.random() * 900).toString();
        const dbKey = `db_${emailPrefix}${randomSuffix}`;
        // Create new database schema
        const db = createSequelizeInstance();
        if (!db) {
            throw new Error('Database not initialized');
        }
        await db.query(`CREATE DATABASE IF NOT EXISTS \`${dbKey}\``);
        console.log(`âœ… Created admin schema: ${dbKey}`);
        return dbKey;
    } catch (error) {
        console.error('âŒ Failed to create admin schema:', error);
        throw error;
    }
};
const getAdminConnection = (dbKey)=>{
    // Determine SSL configuration based on environment
    // Only use SSL if DB_SSL_CA is explicitly set and not empty
    const sslConfig = process.env.DB_SSL_CA && process.env.DB_SSL_CA.trim() !== '' ? {
        require: true,
        rejectUnauthorized: process.env.DB_REJECT_UNAUTHORIZED !== 'false',
        ca: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), process.env.DB_SSL_CA)
    } : ("TURBOPACK compile-time value", "development") === 'production' && process.env.DB_HOST?.includes('azure') ? "TURBOPACK unreachable" : false;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Sequelize"](dbKey, process.env.DB_USER || 'psr_admin', process.env.DB_PASSWORD || '', {
        host: process.env.DB_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || '3306'),
        dialect: 'mysql',
        dialectModule: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
        dialectOptions: {
            ssl: sslConfig,
            connectTimeout: parseInt(process.env.DB_CONNECTION_TIMEOUT || '30') * 1000,
            acquireTimeout: parseInt(process.env.DB_COMMAND_TIMEOUT || '60') * 1000,
            timeout: parseInt(process.env.DB_COMMAND_TIMEOUT || '60') * 1000
        },
        pool: {
            max: parseInt(process.env.DB_POOL_MAX || '10'),
            min: parseInt(process.env.DB_POOL_MIN || '0'),
            acquire: parseInt(process.env.DB_CONNECTION_TIMEOUT || '30') * 1000,
            idle: parseInt(process.env.DB_CONNECTION_LIFETIME || '300') * 1000
        },
        logging: ("TURBOPACK compile-time truthy", 1) ? console.log : "TURBOPACK unreachable"
    });
};
const __TURBOPACK__default__export__ = createSequelizeInstance;
}),
"[project]/src/lib/external-api/BaseExternalAPI.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseExternalAPI",
    ()=>BaseExternalAPI
]);
class BaseExternalAPI {
    config;
    constructor(config){
        this.config = config;
    }
    /**
   * Get error message for this endpoint
   */ getErrorMessage() {
        return this.config.standardErrorMessage;
    }
    /**
   * Main request handler - implements common flow
   */ async handleRequest(request, { params }) {
        try {
            // Step 1: Extract InputString from GET/POST
            let inputString = await this.extractInputString(request);
            // Step 2: Resolve dynamic params
            const resolvedParams = await params;
            const dbKey = resolvedParams['db-key'] || resolvedParams.dbKey || resolvedParams['dbkey'];
            this.logRequest(request, dbKey, inputString);
            // Step 3: Filter line endings if configured
            if (this.config.filterLineEndings && inputString) {
                inputString = this.filterLineEndings(inputString);
            }
            // Step 4: Basic validation
            if (!this.validateBasicInputs(dbKey, inputString)) {
                return this.errorResponse();
            }
            // Step 5: Parse InputString
            const parsedInput = this.parseInput(inputString);
            if (!parsedInput) {
                console.log(`âŒ ${this.config.endpointName}: Failed to parse InputString: "${inputString}"`);
                return this.errorResponse();
            }
            // Step 6: Connect to database and validate
            const { sequelize, schemaName } = await this.connectAndValidate(dbKey);
            if (!sequelize || !schemaName) {
                return this.errorResponse();
            }
            // Step 7: Validate parsed input
            const validation = await this.validateInput(parsedInput, dbKey);
            if (!validation.isValid) {
                console.log(`âŒ ${this.config.endpointName}: Input validation failed: ${validation.error}`);
                return this.errorResponse();
            }
            // Step 8: Execute business logic
            const result = await this.executeBusinessLogic(parsedInput, schemaName, sequelize);
            // Step 9: Format and return response
            const formattedResponse = this.formatResponse(result);
            return this.successResponse(formattedResponse);
        } catch (error) {
            console.error(`âŒ Error in ${this.config.endpointName} API:`, error);
            return this.errorResponse();
        }
    }
    /**
   * Extract InputString from request (GET query param or POST body)
   */ async extractInputString(request) {
        let inputString = null;
        if (request.method === 'GET') {
            const { searchParams } = new URL(request.url);
            inputString = searchParams.get('InputString');
        } else if (request.method === 'POST') {
            try {
                const body = await request.json();
                inputString = body.InputString || null;
            } catch (error) {
                try {
                    const formData = await request.formData();
                    inputString = formData.get('InputString') || null;
                } catch  {
                    console.log(`âŒ Failed to parse POST body:`, error);
                }
            }
        }
        return inputString;
    }
    /**
   * Filter line ending characters from InputString
   */ filterLineEndings(inputString) {
        const originalInputString = inputString;
        // Remove common line ending patterns: $0D (CR), $0A (LF), $0D$0A (CRLF)
        const filtered = inputString.replace(/\$0D\$0A/g, '') // Remove $0D$0A (CRLF)
        .replace(/\$0D/g, '') // Remove $0D (CR) 
        .replace(/\$0A/g, '') // Remove $0A (LF)
        .replace(/\r\n/g, '') // Remove actual CRLF characters
        .replace(/\r/g, '') // Remove actual CR characters
        .replace(/\n/g, ''); // Remove actual LF characters
        if (originalInputString !== filtered) {
            console.log(`ðŸ§¹ ${this.config.endpointName}: Filtered line endings: "${originalInputString}" -> "${filtered}"`);
        }
        return filtered;
    }
    /**
   * Basic input validation
   */ validateBasicInputs(dbKey, inputString) {
        if (!dbKey || dbKey.trim() === '') {
            console.log(`âŒ ${this.config.endpointName}: DB Key validation failed - dbKey: "${dbKey}"`);
            return false;
        }
        if (!inputString) {
            console.log(`âŒ ${this.config.endpointName}: InputString is required`);
            return false;
        }
        // Validate InputString part count
        const parts = inputString.split('|');
        if (!this.config.expectedPartCounts.includes(parts.length)) {
            console.log(`âŒ ${this.config.endpointName}: Invalid InputString part count. Expected: ${this.config.expectedPartCounts.join(' or ')}, Got: ${parts.length}`);
            return false;
        }
        return true;
    }
    /**
   * Connect to database and get admin schema
   */ async connectAndValidate(dbKey) {
        try {
            const { connectDB } = await __turbopack_context__.A("[project]/src/lib/database.ts [app-route] (ecmascript, async loader)");
            await connectDB();
            const { getModels } = await __turbopack_context__.A("[project]/src/models/index.ts [app-route] (ecmascript, async loader)");
            const { sequelize, User } = getModels();
            // Find admin by dbKey to get schema name
            const admin = await User.findOne({
                where: {
                    dbKey: dbKey.toUpperCase()
                }
            });
            if (!admin || !admin.dbKey) {
                console.log(`âŒ ${this.config.endpointName}: Admin not found or missing DB Key for: ${dbKey}`);
                return {
                    sequelize: null,
                    schemaName: null
                };
            }
            // Generate admin-specific schema name
            const cleanAdminName = admin.fullName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
            const schemaName = `${cleanAdminName}_${admin.dbKey.toLowerCase()}`;
            console.log(`âœ… ${this.config.endpointName}: Using schema: ${schemaName}`);
            return {
                sequelize,
                schemaName
            };
        } catch (error) {
            console.error(`âŒ ${this.config.endpointName}: Database connection failed:`, error);
            return {
                sequelize: null,
                schemaName: null
            };
        }
    }
    /**
   * Log request details
   */ logRequest(request, dbKey, inputString) {
        console.log(`ðŸ” ${this.config.endpointName} External API Request - Full URL: ${request.url}`);
        console.log(`ðŸ” DB Key: "${dbKey}", InputString: "${inputString}"`);
        console.log(`ðŸ” DB Key type: ${typeof dbKey}, length: ${dbKey?.length}`);
    }
    /**
   * Create success response
   */ successResponse(data, additionalHeaders) {
        return new Response(`"${data}"`, {
            status: 200,
            headers: {
                'Content-Type': 'text/plain',
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST',
                'Access-Control-Allow-Headers': 'Content-Type',
                ...additionalHeaders
            }
        });
    }
    /**
   * Create error response
   */ errorResponse() {
        return new Response(`"${this.getErrorMessage()}"`, {
            status: 200,
            headers: {
                'Content-Type': 'text/plain'
            }
        });
    }
    /**
   * Handle OPTIONS request for CORS
   */ async handleOptions() {
        return new Response(null, {
            status: 200,
            headers: {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        });
    }
}
}),
"[project]/src/lib/external-api/InputValidator.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Utility class for validating and parsing InputString components
 */ __turbopack_context__.s([
    "InputValidator",
    ()=>InputValidator
]);
class InputValidator {
    /**
   * Validate and parse society ID (handles S- prefix format)
   */ static validateSocietyId(societyIdStr) {
        if (!societyIdStr || typeof societyIdStr === 'string' && societyIdStr.trim() === '') {
            return {
                isValid: false,
                id: societyIdStr,
                fallback: societyIdStr,
                error: 'Society ID cannot be empty'
            };
        }
        // Preserve original format for database lookup
        const id = societyIdStr;
        // Extract fallback ID (remove S- prefix if present)
        let fallback = societyIdStr;
        if (societyIdStr.startsWith('S-')) {
            fallback = societyIdStr.substring(2);
        }
        // Try to parse numeric ID for fallback matching
        let numericId;
        const numericPart = parseInt(fallback);
        if (!isNaN(numericPart)) {
            numericId = numericPart;
        }
        return {
            isValid: true,
            id,
            fallback,
            numericId
        };
    }
    /**
   * Validate and parse machine ID (handles M prefix format with optional letter)
   * 
   * Supports multiple formats:
   * - M00001 -> 1 (numeric)
   * - Mm00001 -> m1 (alphanumeric with letter)
   * - Ma00005 -> a5 (alphanumeric with letter)
   * - M0000df -> df (fully alphanumeric)
   * 
   * @param machineId - Machine ID with M prefix
   * @returns Validation result with parsed IDs and variants
   */ static validateMachineId(machineId) {
        if (!machineId || machineId.trim() === '') {
            return {
                isValid: false,
                error: 'Machine ID is required but not provided'
            };
        }
        // Validate machine ID format (must start with M)
        if (!machineId.startsWith('M') || machineId.length < 2) {
            return {
                isValid: false,
                error: `Invalid machine ID format: "${machineId}"`
            };
        }
        // Remove first 'M' prefix and extract actual machine ID
        // Format: M + optional_letter + numbers
        // Examples: Mm00001 -> m00001, M00001 -> 00001, Ma00005 -> a00005
        const withoutPrefix = machineId.substring(1);
        // Validate that remaining part is alphanumeric
        if (!/^[a-zA-Z0-9]+$/.test(withoutPrefix)) {
            return {
                isValid: false,
                error: `Invalid machine ID format: "${machineId}" - contains invalid characters`
            };
        }
        let processedId;
        let isNumeric = false;
        let numericId;
        let alphanumericId;
        // Check if withoutPrefix contains any letters
        const hasLetters = /[a-zA-Z]/.test(withoutPrefix);
        if (hasLetters) {
            // Contains letters - treat as alphanumeric
            // Examples: m00001, 000m1, 0000df, abc123
            const strippedId = withoutPrefix.replace(/^0+/, '') || withoutPrefix;
            // Check if it starts with a letter after removing zeros
            if (/^[a-zA-Z]/.test(strippedId)) {
                const letter = strippedId.charAt(0).toLowerCase();
                const remainingPart = strippedId.substring(1);
                // Check if remaining part is numeric
                if (/^\d+$/.test(remainingPart)) {
                    // Letter + numbers: m00001 -> m1, 000m1 -> m1
                    const cleanedNumber = remainingPart.replace(/^0+/, '') || '0';
                    processedId = letter + cleanedNumber;
                    alphanumericId = processedId;
                } else {
                    // Mixed alphanumeric: df, abc123
                    processedId = strippedId;
                    alphanumericId = processedId;
                }
            } else {
                // Starts with number but has letters: should not happen after strip
                processedId = strippedId;
                alphanumericId = processedId;
            }
        } else {
            // No letter, just numbers (e.g., 00001 -> 1)
            processedId = withoutPrefix.replace(/^0+/, '') || '0';
            const parsed = parseInt(processedId);
            if (!isNaN(parsed) && parsed > 0) {
                isNumeric = true;
                numericId = parsed;
            } else {
                return {
                    isValid: false,
                    error: `Invalid machine ID: "${machineId}" - invalid numeric format`
                };
            }
        }
        console.log(`ðŸ”„ Machine ID conversion: "${machineId}" -> "${withoutPrefix}" -> "${processedId}"`);
        // Create variants for flexible database matching
        const variants = [];
        if (isNumeric && numericId) {
            // Numeric ID variants
            variants.push(numericId); // Numeric: 1
            variants.push(machineId); // Original: M00001
            variants.push(withoutPrefix); // Without M: 00001
            variants.push(processedId); // Stripped: 1
            variants.push(String(numericId)); // String numeric: "1"
        } else if (alphanumericId) {
            // Alphanumeric ID variants
            variants.push(alphanumericId); // Processed: m1, df
            variants.push(withoutPrefix); // Without M: m00001, 0000df
            // Add stripped version if different
            const strippedVersion = withoutPrefix.replace(/^0+/, '');
            if (strippedVersion && strippedVersion !== alphanumericId && strippedVersion !== withoutPrefix) {
                variants.push(strippedVersion);
            }
        }
        return {
            isValid: true,
            numericId,
            alphanumericId,
            withoutPrefix,
            strippedId: processedId,
            variants,
            isNumeric
        };
    }
    /**
   * Validate DB Key format
   */ static validateDbKey(dbKey) {
        if (!dbKey || dbKey.trim() === '') {
            return {
                isValid: false,
                error: 'DB Key is required'
            };
        }
        // Add additional DB key format validation if needed
        if (dbKey.length < 2) {
            return {
                isValid: false,
                error: 'DB Key must be at least 2 characters'
            };
        }
        return {
            isValid: true
        };
    }
    /**
   * Validate machine model/type (basic validation)
   */ static validateMachineModel(machineModel) {
        if (!machineModel || machineModel.trim() === '') {
            return {
                isValid: true,
                warning: `Machine model is empty: "${machineModel}"`
            };
        }
        return {
            isValid: true
        };
    }
    /**
   * Validate password type for machine password endpoints
   */ static validatePasswordType(passwordType) {
        if (!passwordType) {
            return {
                isValid: false,
                isUser: false,
                isSupervisor: false,
                error: 'Password type is required'
            };
        }
        // Accept both full formats (U$0D, S$0D) and short formats (U, S)
        const isUser = passwordType.startsWith('U');
        const isSupervisor = passwordType.startsWith('S');
        if (!isUser && !isSupervisor) {
            return {
                isValid: false,
                isUser: false,
                isSupervisor: false,
                error: `Invalid password type: "${passwordType}"`
            };
        }
        return {
            isValid: true,
            isUser,
            isSupervisor
        };
    }
}
}),
"[project]/src/lib/external-api/QueryBuilder.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Utility class for building database queries for external APIs
 */ __turbopack_context__.s([
    "QueryBuilder",
    ()=>QueryBuilder
]);
class QueryBuilder {
    /**
   * Build society filter conditions for WHERE clause
   */ static buildSocietyFilter(societyId, fallbackId, numericId) {
        // Support multiple society ID formats:
        // 1. String matching (s.society_id = 'S-s12')
        // 2. Fallback string matching (s.society_id = 's12') 
        // 3. Numeric matching (m.society_id = 12)
        const condition = '(s.society_id = ? OR s.society_id = ? OR m.society_id = ?)';
        const societyIdNumeric = numericId || fallbackId;
        return {
            condition,
            replacements: [
                societyId,
                fallbackId,
                societyIdNumeric
            ]
        };
    }
    /**
   * Build machine filter conditions for WHERE clause
   * Supports both numeric and alphanumeric machine IDs
   * 
   * @param machineValidation - Result from InputValidator.validateMachineId()
   * @param useNumericId - Whether to use numeric ID (m.id) or string ID (m.machine_id)
   */ static buildMachineFilter(machineValidation, useNumericId = true) {
        // For numeric machine IDs (backward compatibility)
        if (machineValidation.isNumeric && machineValidation.numericId && useNumericId) {
            // Direct numeric ID matching: m.id = 1
            return {
                condition: 'm.id = ?',
                replacements: [
                    machineValidation.numericId
                ]
            };
        }
        // For alphanumeric machine IDs or string-based matching
        if (machineValidation.variants && machineValidation.variants.length > 0) {
            // Use IN clause with all variants
            const placeholders = machineValidation.variants.map(()=>'?').join(', ');
            return {
                condition: `m.machine_id IN (${placeholders})`,
                replacements: machineValidation.variants
            };
        }
        // Fallback to direct alphanumeric matching
        if (machineValidation.alphanumericId) {
            return {
                condition: 'm.machine_id = ?',
                replacements: [
                    machineValidation.alphanumericId
                ]
            };
        }
        // Final fallback - should not reach here if validation passed
        throw new Error('Invalid machine validation result for query building');
    }
    /**
   * Build base query with schema, table, and joins
   */ static buildBaseQuery(schemaName, tableName) {
        const escapedSchema = QueryBuilder.escapeIdentifier(schemaName);
        if (tableName === 'farmers') {
            return `
        FROM ${escapedSchema}.farmers f
        LEFT JOIN ${escapedSchema}.societies s ON f.society_id = s.id
        LEFT JOIN ${escapedSchema}.machines m ON f.machine_id = m.id
      `;
        } else if (tableName === 'machines') {
            return `
        FROM ${escapedSchema}.machines m
        LEFT JOIN ${escapedSchema}.societies s ON m.society_id = s.id
      `;
        } else {
            throw new Error(`Unsupported table name: ${tableName}`);
        }
    }
    /**
   * Build complete SELECT query for farmer info
   */ static buildFarmerQuery(schemaName, societyFilter, machineFilter, pagination) {
        const baseQuery = QueryBuilder.buildBaseQuery(schemaName, 'farmers');
        let query = `
      SELECT 
        f.id, 
        f.farmer_id,
        f.rf_id, 
        f.name, 
        f.phone, 
        f.sms_enabled, 
        f.bonus
      ${baseQuery}
      WHERE ${societyFilter.condition}
        AND f.status = 'active'
        AND ${machineFilter.condition}
      ORDER BY f.farmer_id
    `;
        let replacements = [
            ...societyFilter.replacements,
            ...machineFilter.replacements
        ];
        if (pagination) {
            query += ' LIMIT ? OFFSET ?';
            replacements = [
                ...replacements,
                pagination.limit,
                pagination.offset
            ];
        }
        return {
            query,
            replacements
        };
    }
    /**
   * Build complete SELECT query for machine password
   */ static buildMachinePasswordQuery(schemaName, societyFilter, machineFilter) {
        const baseQuery = QueryBuilder.buildBaseQuery(schemaName, 'machines');
        const query = `
      SELECT 
        m.id, 
        m.machine_id, 
        m.user_password, 
        m.supervisor_password, 
        m.statusU, 
        m.statusS,
        s.society_id as society_string_id
      ${baseQuery}
      WHERE ${societyFilter.condition}
        AND ${machineFilter.condition}
        AND m.status = 'active'
    `;
        const replacements = [
            ...societyFilter.replacements,
            ...machineFilter.replacements
        ];
        return {
            query,
            replacements
        };
    }
    /**
   * Build society lookup query to get database ID from society_id string
   */ static buildSocietyLookupQuery(schemaName, societyIdStr) {
        const escapedSchema = QueryBuilder.escapeIdentifier(schemaName);
        // Try both with and without S- prefix
        const lookupParams = societyIdStr.startsWith('S-') ? [
            societyIdStr,
            societyIdStr.substring(2)
        ] : [
            `S-${societyIdStr}`,
            societyIdStr
        ];
        const query = `
      SELECT id FROM ${escapedSchema}.societies 
      WHERE society_id = ? OR society_id = ?
      LIMIT 1
    `;
        return {
            query,
            replacements: lookupParams
        };
    }
    /**
   * Safely escape database identifiers (schema/table names)
   */ static escapeIdentifier(identifier) {
        // Remove any non-alphanumeric characters except underscores
        const cleaned = identifier.replace(/[^a-zA-Z0-9_]/g, '');
        return `\`${cleaned}\``;
    }
    /**
   * Build pagination parameters
   */ static buildPagination(pageNumber, pageSize = 5) {
        const normalizedPageNumber = Math.max(1, pageNumber);
        const offset = (normalizedPageNumber - 1) * pageSize;
        return {
            limit: pageSize,
            offset,
            pageNumber: normalizedPageNumber
        };
    }
    /**
   * Extract page number from C parameter format (C00001 = page 1, C00002 = page 2)
   */ static parsePageNumber(lengthParam) {
        if (!lengthParam || !lengthParam.startsWith('C')) {
            return 1;
        }
        const pageNumber = parseInt(lengthParam.replace(/^C0*/, '')) || 1;
        return Math.max(1, pageNumber);
    }
}
}),
"[project]/src/lib/external-api/ResponseFormatter.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Response formatting utilities for external APIs
 */ __turbopack_context__.s([
    "ResponseFormatter",
    ()=>ResponseFormatter
]);
class ResponseFormatter {
    /**
   * Format farmer data for CSV download
   */ static formatFarmerCSV(farmers) {
        const csvHeader = 'ID,RF-ID,NAME,MOBILE,SMS,BONUS\n';
        const csvData = farmers.map((farmer)=>{
            const phone = farmer.phone || '';
            const smsEnabled = farmer.sms_enabled || 'OFF';
            // Convert bonus to number and format without decimal places (matching sample format)
            let bonus = '0';
            if (farmer.bonus !== null && farmer.bonus !== undefined) {
                const bonusNum = Number(farmer.bonus);
                bonus = isNaN(bonusNum) ? '0' : Math.round(bonusNum).toString();
            }
            // Escape CSV values that contain commas or quotes
            const escapeCsv = (value)=>{
                if (value.includes(',') || value.includes('"')) {
                    return `"${value.replace(/"/g, '""')}"`;
                }
                return value;
            };
            return `${farmer.id},${escapeCsv(farmer.farmer_id)},${escapeCsv(farmer.name)},${escapeCsv(phone)},${smsEnabled},${bonus}`;
        }).join('\n');
        return csvHeader + csvData;
    }
    /**
   * Format farmer data for pagination response (pipe-delimited)
   */ static formatFarmerPagination(farmers) {
        // Format: id|farmer_id|name|phone|sms_enabled|bonus||
        // Each farmer separated by ||, fields separated by |
        const responseData = farmers.map((farmer)=>{
            const phone = farmer.phone || '';
            const smsEnabled = farmer.sms_enabled || 'OFF';
            // Convert bonus to number and format with 2 decimal places
            let bonus = '0.00';
            if (farmer.bonus !== null && farmer.bonus !== undefined) {
                const bonusNum = Number(farmer.bonus);
                bonus = isNaN(bonusNum) ? '0.00' : bonusNum.toFixed(2);
            }
            return `${farmer.id}|${farmer.farmer_id}|${farmer.name}|${phone}|${smsEnabled}|${bonus}`;
        }).join('||');
        return responseData;
    }
    /**
   * Format machine password response
   */ static formatMachinePassword(passwordType, password) {
        if (passwordType.isUser) {
            return `PU|${password}`;
        } else if (passwordType.isSupervisor) {
            return `PS|${password}`;
        }
        throw new Error('Invalid password type for formatting');
    }
    /**
   * Create standard success response with proper headers
   */ static createSuccessResponse(data, contentType = 'text/plain', additionalHeaders) {
        const headers = {
            'Content-Type': contentType,
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST',
            'Access-Control-Allow-Headers': 'Content-Type',
            ...additionalHeaders
        };
        // Add CSV-specific headers
        if (contentType === 'text/csv') {
            headers['Content-Disposition'] = 'attachment; filename="FarmerDetails.csv"';
        }
        return new Response(`"${data}"`, {
            status: 200,
            headers
        });
    }
    /**
   * Create standard error response
   */ static createErrorResponse(errorMessage) {
        return new Response(`"${errorMessage}"`, {
            status: 200,
            headers: {
                'Content-Type': 'text/plain'
            }
        });
    }
    /**
   * Create CORS preflight response
   */ static createCORSResponse() {
        return new Response(null, {
            status: 200,
            headers: {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        });
    }
    /**
   * Wrap response data in quotes (external API standard)
   */ static wrapInQuotes(data) {
        return `"${data}"`;
    }
    /**
   * Log response details for debugging
   */ static logResponse(endpointName, dataType, itemCount, responsePreview) {
        console.log(`ðŸ“¤ ${endpointName}: Returning ${dataType} for ${itemCount} items`);
        if (responsePreview) {
            const preview = responsePreview.length > 100 ? `${responsePreview.substring(0, 100)}...` : responsePreview;
            console.log(`ðŸ“¤ Response preview: ${preview}`);
        }
    }
    /**
   * Log CSV response details
   */ static logCSVResponse(endpointName, itemCount, csvSize) {
        console.log(`ðŸ“ ${endpointName}: Returning CSV data for ${itemCount} items`);
        console.log(`ðŸ“ CSV size: ${csvSize} characters`);
    }
}
}),
"[project]/src/lib/external-api/ESP32ResponseHelper.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * ESP32-Friendly Response Helper
 * 
 * Utilities for creating responses compatible with ESP32 WiFi modules
 * 
 * Key Requirements:
 * - Always return HTTP 200 status (even for errors)
 * - No quotes around response text for simple messages
 * - Specific headers: charset=utf-8, Content-Length, Connection: close
 * - Cache-Control: no-cache for fresh data
 */ __turbopack_context__.s([
    "ESP32ResponseHelper",
    ()=>ESP32ResponseHelper
]);
class ESP32ResponseHelper {
    /**
   * Create ESP32-friendly success response
   * @param data - Response data (will be quoted by default)
   * @param options - Additional options
   */ static createResponse(data, options) {
        const { contentType = 'text/plain; charset=utf-8', addQuotes = true, additionalHeaders = {} } = options || {};
        // Wrap response in double quotes by default for ESP32 compatibility
        const responseBody = addQuotes ? `"${data}"` : data;
        const contentLength = Buffer.byteLength(responseBody, 'utf8');
        return new Response(responseBody, {
            status: 200,
            headers: {
                'Content-Type': contentType,
                'Content-Length': contentLength.toString(),
                'Connection': 'close',
                'Cache-Control': 'no-cache',
                'Access-Control-Allow-Origin': '*',
                ...additionalHeaders
            }
        });
    }
    /**
   * Create ESP32-friendly error response (still returns 200 status)
   */ static createErrorResponse(errorMessage) {
        return ESP32ResponseHelper.createResponse(errorMessage);
    }
    /**
   * Create success response with structured data (pipe-delimited format)
   */ static createDataResponse(data) {
        return ESP32ResponseHelper.createResponse(data, {
            additionalHeaders: {
                'Access-Control-Allow-Methods': 'GET, POST',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        });
    }
    /**
   * Create CSV response with proper headers
   */ static createCSVResponse(csvData, filename = 'data.csv') {
        return new Response(csvData, {
            status: 200,
            headers: {
                'Content-Type': 'text/csv; charset=utf-8',
                'Content-Disposition': `attachment; filename="${filename}"`,
                'Content-Length': Buffer.byteLength(csvData, 'utf8').toString(),
                'Connection': 'close',
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        });
    }
    /**
   * Create CORS preflight response
   */ static createCORSResponse() {
        return new Response(null, {
            status: 200,
            headers: {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        });
    }
    /**
   * Extract InputString from request (handles malformed URLs from ESP32)
   */ static async extractInputString(request) {
        let inputString = null;
        if (request.method === 'GET') {
            const { searchParams } = new URL(request.url);
            inputString = searchParams.get('InputString');
            // Handle malformed URLs from ESP32 (e.g., "?,InputString=...")
            if (!inputString) {
                // Check if any param key contains "InputString" (handles ",InputString" case)
                for (const [key, value] of searchParams.entries()){
                    if (key.includes('InputString')) {
                        inputString = value;
                        console.log(`   âœ… ESP32: Found InputString in malformed param key: "${key}"`);
                        break;
                    }
                }
            }
        } else if (request.method === 'POST') {
            try {
                const body = await request.json();
                inputString = body.InputString || null;
            } catch  {
                try {
                    const formData = await request.formData();
                    inputString = formData.get('InputString') || null;
                } catch (error) {
                    console.log(`âŒ ESP32: Failed to parse POST body:`, error);
                }
            }
        }
        return inputString;
    }
    /**
   * Filter line ending characters from InputString
   * ESP32 sends $0D, $0A, $0D$0A patterns
   */ static filterLineEndings(inputString) {
        if (!inputString) return inputString;
        const original = inputString;
        // Remove common line ending patterns
        const filtered = inputString.replace(/\$0D\$0A/g, '') // CRLF
        .replace(/\$0D/g, '') // CR
        .replace(/\$0A/g, '') // LF
        .replace(/\r\n/g, '') // Actual CRLF
        .replace(/\r/g, '') // Actual CR
        .replace(/\n/g, ''); // Actual LF
        if (original !== filtered) {
            console.log(`ðŸ§¹ ESP32: Filtered line endings: "${original}" -> "${filtered}"`);
        }
        return filtered;
    }
    /**
   * Log ESP32 request details for debugging
   */ static logRequest(request, dbKey, inputString) {
        console.log(`\n${'='.repeat(80)}`);
        console.log(`ðŸ“¡ ESP32 External API Request:`);
        console.log(`   Timestamp: ${new Date().toISOString()}`);
        console.log(`   Method: ${request.method}`);
        console.log(`   Full URL: ${request.url}`);
        console.log(`   DB Key: "${dbKey}"`);
        console.log(`   InputString: "${inputString}"`);
        console.log(`   Headers:`, {
            'user-agent': request.headers.get('user-agent'),
            'content-type': request.headers.get('content-type'),
            'connection': request.headers.get('connection'),
            'host': request.headers.get('host')
        });
        console.log(`${'='.repeat(80)}\n`);
    }
}
}),
"[project]/src/lib/external-api/index.ts [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// External API pattern base classes and utilities
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$BaseExternalAPI$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/BaseExternalAPI.ts [app-route] (ecmascript)");
// Input validation utilities
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$InputValidator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/InputValidator.ts [app-route] (ecmascript)");
// Database query building utilities
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$QueryBuilder$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/QueryBuilder.ts [app-route] (ecmascript)");
// Response formatting utilities  
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ResponseFormatter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/ResponseFormatter.ts [app-route] (ecmascript)");
// ESP32-specific response utilities
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/ESP32ResponseHelper.ts [app-route] (ecmascript)");
;
;
;
;
;
}),
"[project]/src/app/api/[db-key]/MachineStatistics/SaveMachineStatisticsFromMachine/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET,
    "OPTIONS",
    ()=>OPTIONS,
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/database.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$index$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/src/lib/external-api/index.ts [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/ESP32ResponseHelper.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$InputValidator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/InputValidator.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$QueryBuilder$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/QueryBuilder.ts [app-route] (ecmascript)");
;
;
/**
 * SaveMachineStatisticsFromMachine API Endpoint
 * 
 * Purpose: Save machine statistics data from ESP32 machines
 * InputString format: societyId|machineType|version|machineId|T30|D1|W1|S8|G2|ENABLE|D2025-11-15_12:31:04
 * 
 * Parameters:
 * - societyId: Society identifier (e.g., S-101)
 * - machineType: Machine type (e.g., LSE-SVWTBQ-12AH)
 * - version: Machine version (e.g., LE3.36)
 * - machineId: Machine identifier (e.g., MM223202)
 * - T30: Total tests count
 * - D1: Daily cleaning count
 * - W1: Weekly cleaning count
 * - S8: Cleaning skip count
 * - G2: Gain value
 * - ENABLE/DISABLE: Auto channel status
 * - D2025-11-15_12:31:04: Date and time stamp
 * 
 * Endpoint: GET/POST /api/[db-key]/MachineStatistics/SaveMachineStatisticsFromMachine
 */ async function handleRequest(request, { params }) {
    try {
        // Extract InputString using helper
        let inputString = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].extractInputString(request);
        // Await the params Promise
        const resolvedParams = await params;
        const dbKey = resolvedParams['db-key'] || resolvedParams.dbKey || resolvedParams['dbkey'];
        // Filter line endings from InputString
        if (inputString) {
            inputString = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].filterLineEndings(inputString);
        }
        // Log request
        console.log(`\n${'='.repeat(80)}`);
        console.log(`ðŸ“Š SaveMachineStatisticsFromMachine API Request:`);
        console.log(`   Timestamp: ${new Date().toISOString()}`);
        __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].logRequest(request, dbKey, inputString);
        // Validate DB Key
        const dbKeyValidation = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$InputValidator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InputValidator"].validateDbKey(dbKey);
        if (!dbKeyValidation.isValid) {
            console.log(`âŒ DB Key validation failed`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Invalid DB Key');
        }
        // Validate InputString is provided
        if (!inputString) {
            console.log(`âŒ InputString is missing`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('InputString parameter is required');
        }
        // Connect to database and validate DB Key
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["connectDB"])();
        const { getModels } = await __turbopack_context__.A("[project]/src/models/index.ts [app-route] (ecmascript, async loader)");
        const { sequelize, User } = getModels();
        // Find admin by dbKey to get schema name
        const admin = await User.findOne({
            where: {
                dbKey: dbKey.toUpperCase()
            }
        });
        if (!admin || !admin.dbKey) {
            console.log(`âŒ Admin not found for DB Key: ${dbKey}`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Invalid DB Key');
        }
        // Parse input string format: S-101|LSE-SVWTBQ-12AH|LE3.36|MM223202|T30|D1|W1|S8|G2|ENABLE|D2025-11-15_12:31:04
        const inputParts = inputString.split('|');
        if (inputParts.length !== 11) {
            console.log(`âŒ Invalid InputString format. Expected 11 parts, got ${inputParts.length}`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Invalid InputString format');
        }
        const [societyIdStr, machineType, version, machineId, totalTestStr, dailyCleaningStr, weeklyCleaningStr, cleaningSkipStr, gainStr, autoChannel, dateTimeStr] = inputParts;
        console.log(`ðŸ” Parsed InputString:`, {
            societyIdStr,
            machineType,
            version,
            machineId,
            totalTestStr,
            dailyCleaningStr,
            weeklyCleaningStr,
            cleaningSkipStr,
            gainStr,
            autoChannel,
            dateTimeStr
        });
        // Validate Society ID
        const societyValidation = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$InputValidator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InputValidator"].validateSocietyId(societyIdStr);
        if (!societyValidation.isValid) {
            console.log(`âŒ Invalid society ID: ${societyIdStr}`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Invalid society ID');
        }
        // Validate Machine ID
        const machineValidation = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$InputValidator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InputValidator"].validateMachineId(machineId);
        if (!machineValidation.isValid) {
            console.log(`âŒ Invalid machine ID: ${machineId}`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Invalid machine ID format');
        }
        // Parse statistics values
        const totalTest = parseInt(totalTestStr.substring(1)) || 0; // Remove 'T' prefix
        const dailyCleaning = parseInt(dailyCleaningStr.substring(1)) || 0; // Remove 'D' prefix
        const weeklyCleaning = parseInt(weeklyCleaningStr.substring(1)) || 0; // Remove 'W' prefix
        const cleaningSkip = parseInt(cleaningSkipStr.substring(1)) || 0; // Remove 'S' prefix
        const gain = parseInt(gainStr.substring(1)) || 0; // Remove 'G' prefix
        // Parse date and time from format: D2025-11-15_12:31:04
        const dateTimePart = dateTimeStr.substring(1); // Remove 'D' prefix
        const [datePart, timePart] = dateTimePart.split('_');
        const statisticsDate = datePart; // 2025-11-15
        const statisticsTime = timePart; // 12:31:04
        console.log(`ðŸ“Š Parsed statistics:`, {
            totalTest,
            dailyCleaning,
            weeklyCleaning,
            cleaningSkip,
            gain,
            autoChannel,
            statisticsDate,
            statisticsTime
        });
        // Build schema name
        const cleanAdminName = admin.fullName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
        const schemaName = `${cleanAdminName}_${admin.dbKey.toLowerCase()}`;
        console.log(`ðŸ” Using schema: ${schemaName}`);
        // Look up society
        const { query: societyQuery, replacements: societyReplacements } = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$QueryBuilder$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QueryBuilder"].buildSocietyLookupQuery(schemaName, societyIdStr);
        const [societyResults] = await sequelize.query(societyQuery, {
            replacements: societyReplacements
        });
        if (!Array.isArray(societyResults) || societyResults.length === 0) {
            console.log(`âŒ Society not found: "${societyIdStr}"`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Invalid society ID');
        }
        const actualSocietyId = societyResults[0].id;
        console.log(`âœ… Found society: "${societyIdStr}" -> database ID: ${actualSocietyId}`);
        // Look up machine to verify it exists
        const machineIdVariants = (machineValidation.variants || []).map((v)=>String(v));
        if (machineIdVariants.length === 0) {
            const machineIdCleaned = machineValidation.alphanumericId || machineValidation.numericId?.toString() || machineValidation.strippedId || '';
            machineIdVariants.push(machineIdCleaned);
        }
        const placeholders = machineIdVariants.map(()=>'?').join(', ');
        const machineQuery = `
      SELECT id, machine_id, society_id 
      FROM \`${schemaName}\`.machines 
      WHERE machine_id IN (${placeholders}) AND society_id = ?
      LIMIT 1
    `;
        const [machineResults] = await sequelize.query(machineQuery, {
            replacements: [
                ...machineIdVariants,
                actualSocietyId
            ]
        });
        if (!Array.isArray(machineResults) || machineResults.length === 0) {
            console.log(`âŒ Machine not found: "${machineId}" for society ${actualSocietyId}`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Invalid machine ID');
        }
        const machineData = machineResults[0];
        console.log(`âœ… Found machine: "${machineId}" -> database ID: ${machineData.id}`);
        // Check if statistics already exist for today
        const checkQuery = `
      SELECT id FROM \`${schemaName}\`.machine_statistics 
      WHERE machine_id = ? AND DATE(created_at) = CURDATE()
      LIMIT 1
    `;
        const [existingResults] = await sequelize.query(checkQuery, {
            replacements: [
                machineData.id
            ]
        });
        if (Array.isArray(existingResults) && existingResults.length > 0) {
            // Update existing record for today
            console.log(`ðŸ“ Updating today's statistics for machine ${machineData.id}`);
            const updateQuery = `
        UPDATE \`${schemaName}\`.machine_statistics 
        SET 
          society_id = ?,
          machine_type = ?,
          version = ?,
          total_test = ?,
          daily_cleaning = ?,
          weekly_cleaning = ?,
          cleaning_skip = ?,
          gain = ?,
          auto_channel = ?,
          statistics_date = ?,
          statistics_time = ?
        WHERE machine_id = ? AND DATE(created_at) = CURDATE()
      `;
            await sequelize.query(updateQuery, {
                replacements: [
                    actualSocietyId,
                    machineType,
                    version,
                    totalTest,
                    dailyCleaning,
                    weeklyCleaning,
                    cleaningSkip,
                    gain,
                    autoChannel,
                    statisticsDate,
                    statisticsTime,
                    machineData.id
                ]
            });
            console.log(`âœ… Today's machine statistics updated successfully`);
        } else {
            // Insert new record for today
            console.log(`ðŸ“ Creating new statistics record for machine ${machineData.id}`);
            const insertQuery = `
        INSERT INTO \`${schemaName}\`.machine_statistics 
        (
          machine_id, 
          society_id, 
          machine_type, 
          version, 
          total_test, 
          daily_cleaning, 
          weekly_cleaning, 
          cleaning_skip, 
          gain, 
          auto_channel, 
          statistics_date, 
          statistics_time
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `;
            await sequelize.query(insertQuery, {
                replacements: [
                    machineData.id,
                    actualSocietyId,
                    machineType,
                    version,
                    totalTest,
                    dailyCleaning,
                    weeklyCleaning,
                    cleaningSkip,
                    gain,
                    autoChannel,
                    statisticsDate,
                    statisticsTime
                ]
            });
            console.log(`âœ… New machine statistics created successfully`);
        }
        console.log(`${'='.repeat(80)}\n`);
        // Return success response
        return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createDataResponse('Machine statistics saved successfully.');
    } catch (error) {
        console.error('âŒ SaveMachineStatisticsFromMachine API Error:', error);
        console.error('Stack trace:', error instanceof Error ? error.stack : 'No stack trace');
        console.log(`${'='.repeat(80)}\n`);
        return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Failed to save machine statistics');
    }
}
async function GET(request, context) {
    return handleRequest(request, context);
}
async function POST(request, context) {
    return handleRequest(request, context);
}
async function OPTIONS() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createCORSResponse();
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__74c6641e._.js.map