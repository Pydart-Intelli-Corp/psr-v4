module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/timers [external] (timers, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("timers", () => require("timers"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/process [external] (process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[project]/src/lib/database.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "connectDB",
    ()=>connectDB,
    "createAdminSchema",
    ()=>createAdminSchema,
    "default",
    ()=>__TURBOPACK__default__export__,
    "getAdminConnection",
    ()=>getAdminConnection,
    "initDatabase",
    ()=>initDatabase,
    "testConnection",
    ()=>testConnection
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sequelize/lib/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mysql2/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
;
// Database configuration for Azure MySQL
let sequelize = null;
const createSequelizeInstance = ()=>{
    if (!sequelize) {
        // Don't initialize during build time
        if ("TURBOPACK compile-time truthy", 1) {
            // Determine SSL configuration based on environment
            // Only use SSL if DB_SSL_CA is explicitly set and not empty
            const sslConfig = process.env.DB_SSL_CA && process.env.DB_SSL_CA.trim() !== '' ? {
                require: true,
                rejectUnauthorized: process.env.DB_REJECT_UNAUTHORIZED !== 'false',
                ca: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), process.env.DB_SSL_CA)
            } : ("TURBOPACK compile-time value", "development") === 'production' && process.env.DB_HOST?.includes('azure') ? "TURBOPACK unreachable" : false;
            sequelize = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Sequelize"](process.env.DB_NAME || 'psr_v4_main', process.env.DB_USER || 'psr_admin', process.env.DB_PASSWORD || 'Access@404', {
                host: process.env.DB_HOST || 'localhost',
                port: parseInt(process.env.DB_PORT || '3306'),
                dialect: 'mysql',
                dialectModule: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
                timezone: '+05:30',
                dialectOptions: {
                    ssl: sslConfig,
                    connectTimeout: parseInt(process.env.DB_CONNECTION_TIMEOUT || '30') * 1000
                },
                pool: {
                    max: parseInt(process.env.DB_POOL_MAX || '10'),
                    min: parseInt(process.env.DB_POOL_MIN || '0'),
                    acquire: parseInt(process.env.DB_CONNECTION_TIMEOUT || '30') * 1000,
                    idle: parseInt(process.env.DB_CONNECTION_LIFETIME || '300') * 1000
                },
                logging: ("TURBOPACK compile-time truthy", 1) ? console.log : "TURBOPACK unreachable",
                benchmark: ("TURBOPACK compile-time value", "development") === 'development'
            });
        }
    }
    return sequelize;
};
const testConnection = async ()=>{
    try {
        const db = createSequelizeInstance();
        if (!db) {
            console.error('âŒ Database not initialized');
            return false;
        }
        await db.authenticate();
        console.log('âœ… Database connection established successfully.');
        return true;
    } catch (error) {
        console.error('âŒ Unable to connect to the database:', error);
        return false;
    }
};
const initDatabase = async (useMigrations = false)=>{
    try {
        const db = createSequelizeInstance();
        if (!db) {
            console.error('âŒ Database not initialized');
            return false;
        }
        if (useMigrations) {
            // Use migrations instead of sync for production
            const { migrationRunner } = await __turbopack_context__.A("[project]/src/lib/migrations.ts [app-route] (ecmascript, async loader)");
            await migrationRunner.initializeDatabase();
        } else {
            // Development mode - use sync
            await db.sync({
                alter: ("TURBOPACK compile-time value", "development") === 'development'
            });
        }
        console.log('âœ… Database synchronized successfully.');
        return true;
    } catch (error) {
        console.error('âŒ Database synchronization failed:', error);
        return false;
    }
};
const connectDB = async ()=>{
    try {
        const db = createSequelizeInstance();
        if (!db) {
            throw new Error('Database not initialized');
        }
        await db.authenticate();
        return db;
    } catch (error) {
        console.error('âŒ Database connection failed:', error);
        throw error;
    }
};
const createAdminSchema = async (adminEmail)=>{
    try {
        // Generate DB key: db-<first 3 letters of email><3 random numbers>
        const emailPrefix = adminEmail.substring(0, 3).toLowerCase();
        const randomSuffix = Math.floor(100 + Math.random() * 900).toString();
        const dbKey = `db_${emailPrefix}${randomSuffix}`;
        // Create new database schema
        const db = createSequelizeInstance();
        if (!db) {
            throw new Error('Database not initialized');
        }
        await db.query(`CREATE DATABASE IF NOT EXISTS \`${dbKey}\``);
        console.log(`âœ… Created admin schema: ${dbKey}`);
        return dbKey;
    } catch (error) {
        console.error('âŒ Failed to create admin schema:', error);
        throw error;
    }
};
const getAdminConnection = (dbKey)=>{
    // Determine SSL configuration based on environment
    // Only use SSL if DB_SSL_CA is explicitly set and not empty
    const sslConfig = process.env.DB_SSL_CA && process.env.DB_SSL_CA.trim() !== '' ? {
        require: true,
        rejectUnauthorized: process.env.DB_REJECT_UNAUTHORIZED !== 'false',
        ca: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), process.env.DB_SSL_CA)
    } : ("TURBOPACK compile-time value", "development") === 'production' && process.env.DB_HOST?.includes('azure') ? "TURBOPACK unreachable" : false;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Sequelize"](dbKey, process.env.DB_USER || 'psr_admin', process.env.DB_PASSWORD || '', {
        host: process.env.DB_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || '3306'),
        dialect: 'mysql',
        dialectModule: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
        dialectOptions: {
            ssl: sslConfig,
            connectTimeout: parseInt(process.env.DB_CONNECTION_TIMEOUT || '30') * 1000,
            acquireTimeout: parseInt(process.env.DB_COMMAND_TIMEOUT || '60') * 1000,
            timeout: parseInt(process.env.DB_COMMAND_TIMEOUT || '60') * 1000
        },
        pool: {
            max: parseInt(process.env.DB_POOL_MAX || '10'),
            min: parseInt(process.env.DB_POOL_MIN || '0'),
            acquire: parseInt(process.env.DB_CONNECTION_TIMEOUT || '30') * 1000,
            idle: parseInt(process.env.DB_CONNECTION_LIFETIME || '300') * 1000
        },
        logging: ("TURBOPACK compile-time truthy", 1) ? console.log : "TURBOPACK unreachable"
    });
};
const __TURBOPACK__default__export__ = createSequelizeInstance;
}),
"[project]/src/lib/external-api/BaseExternalAPI.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseExternalAPI",
    ()=>BaseExternalAPI
]);
class BaseExternalAPI {
    config;
    constructor(config){
        this.config = config;
    }
    /**
   * Get error message for this endpoint
   */ getErrorMessage() {
        return this.config.standardErrorMessage;
    }
    /**
   * Main request handler - implements common flow
   */ async handleRequest(request, { params }) {
        try {
            // Step 1: Extract InputString from GET/POST
            let inputString = await this.extractInputString(request);
            // Step 2: Resolve dynamic params
            const resolvedParams = await params;
            const dbKey = resolvedParams['db-key'] || resolvedParams.dbKey || resolvedParams['dbkey'];
            this.logRequest(request, dbKey, inputString);
            // Step 3: Filter line endings if configured
            if (this.config.filterLineEndings && inputString) {
                inputString = this.filterLineEndings(inputString);
            }
            // Step 4: Basic validation
            if (!this.validateBasicInputs(dbKey, inputString)) {
                return this.errorResponse();
            }
            // Step 5: Parse InputString
            const parsedInput = this.parseInput(inputString);
            if (!parsedInput) {
                console.log(`âŒ ${this.config.endpointName}: Failed to parse InputString: "${inputString}"`);
                return this.errorResponse();
            }
            // Step 6: Connect to database and validate
            const { sequelize, schemaName } = await this.connectAndValidate(dbKey);
            if (!sequelize || !schemaName) {
                return this.errorResponse();
            }
            // Step 7: Validate parsed input
            const validation = await this.validateInput(parsedInput, dbKey);
            if (!validation.isValid) {
                console.log(`âŒ ${this.config.endpointName}: Input validation failed: ${validation.error}`);
                return this.errorResponse();
            }
            // Step 8: Execute business logic
            const result = await this.executeBusinessLogic(parsedInput, schemaName, sequelize);
            // Step 9: Format and return response
            const formattedResponse = this.formatResponse(result);
            return this.successResponse(formattedResponse);
        } catch (error) {
            console.error(`âŒ Error in ${this.config.endpointName} API:`, error);
            return this.errorResponse();
        }
    }
    /**
   * Extract InputString from request (GET query param or POST body)
   */ async extractInputString(request) {
        let inputString = null;
        if (request.method === 'GET') {
            const { searchParams } = new URL(request.url);
            inputString = searchParams.get('InputString');
        } else if (request.method === 'POST') {
            try {
                const body = await request.json();
                inputString = body.InputString || null;
            } catch (error) {
                try {
                    const formData = await request.formData();
                    inputString = formData.get('InputString') || null;
                } catch  {
                    console.log(`âŒ Failed to parse POST body:`, error);
                }
            }
        }
        return inputString;
    }
    /**
   * Filter line ending characters from InputString
   */ filterLineEndings(inputString) {
        const originalInputString = inputString;
        // Remove common line ending patterns: $0D (CR), $0A (LF), $0D$0A (CRLF)
        const filtered = inputString.replace(/\$0D\$0A/g, '') // Remove $0D$0A (CRLF)
        .replace(/\$0D/g, '') // Remove $0D (CR) 
        .replace(/\$0A/g, '') // Remove $0A (LF)
        .replace(/\r\n/g, '') // Remove actual CRLF characters
        .replace(/\r/g, '') // Remove actual CR characters
        .replace(/\n/g, ''); // Remove actual LF characters
        if (originalInputString !== filtered) {
            console.log(`ðŸ§¹ ${this.config.endpointName}: Filtered line endings: "${originalInputString}" -> "${filtered}"`);
        }
        return filtered;
    }
    /**
   * Basic input validation
   */ validateBasicInputs(dbKey, inputString) {
        if (!dbKey || dbKey.trim() === '') {
            console.log(`âŒ ${this.config.endpointName}: DB Key validation failed - dbKey: "${dbKey}"`);
            return false;
        }
        if (!inputString) {
            console.log(`âŒ ${this.config.endpointName}: InputString is required`);
            return false;
        }
        // Validate InputString part count
        const parts = inputString.split('|');
        if (!this.config.expectedPartCounts.includes(parts.length)) {
            console.log(`âŒ ${this.config.endpointName}: Invalid InputString part count. Expected: ${this.config.expectedPartCounts.join(' or ')}, Got: ${parts.length}`);
            return false;
        }
        return true;
    }
    /**
   * Connect to database and get admin schema
   */ async connectAndValidate(dbKey) {
        try {
            const { connectDB } = await __turbopack_context__.A("[project]/src/lib/database.ts [app-route] (ecmascript, async loader)");
            await connectDB();
            const { getModels } = await __turbopack_context__.A("[project]/src/models/index.ts [app-route] (ecmascript, async loader)");
            const { sequelize, User } = getModels();
            // Find admin by dbKey to get schema name
            const admin = await User.findOne({
                where: {
                    dbKey: dbKey.toUpperCase()
                }
            });
            if (!admin || !admin.dbKey) {
                console.log(`âŒ ${this.config.endpointName}: Admin not found or missing DB Key for: ${dbKey}`);
                return {
                    sequelize: null,
                    schemaName: null
                };
            }
            // Generate admin-specific schema name
            const cleanAdminName = admin.fullName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
            const schemaName = `${cleanAdminName}_${admin.dbKey.toLowerCase()}`;
            console.log(`âœ… ${this.config.endpointName}: Using schema: ${schemaName}`);
            return {
                sequelize,
                schemaName
            };
        } catch (error) {
            console.error(`âŒ ${this.config.endpointName}: Database connection failed:`, error);
            return {
                sequelize: null,
                schemaName: null
            };
        }
    }
    /**
   * Log request details
   */ logRequest(request, dbKey, inputString) {
        console.log(`ðŸ” ${this.config.endpointName} External API Request - Full URL: ${request.url}`);
        console.log(`ðŸ” DB Key: "${dbKey}", InputString: "${inputString}"`);
        console.log(`ðŸ” DB Key type: ${typeof dbKey}, length: ${dbKey?.length}`);
    }
    /**
   * Create success response
   */ successResponse(data, additionalHeaders) {
        return new Response(`"${data}"`, {
            status: 200,
            headers: {
                'Content-Type': 'text/plain',
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST',
                'Access-Control-Allow-Headers': 'Content-Type',
                ...additionalHeaders
            }
        });
    }
    /**
   * Create error response
   */ errorResponse() {
        return new Response(`"${this.getErrorMessage()}"`, {
            status: 200,
            headers: {
                'Content-Type': 'text/plain'
            }
        });
    }
    /**
   * Handle OPTIONS request for CORS
   */ async handleOptions() {
        return new Response(null, {
            status: 200,
            headers: {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        });
    }
}
}),
"[project]/src/lib/external-api/InputValidator.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Utility class for validating and parsing InputString components
 */ __turbopack_context__.s([
    "InputValidator",
    ()=>InputValidator
]);
class InputValidator {
    /**
   * Validate and parse society ID (handles S- prefix format)
   */ static validateSocietyId(societyIdStr) {
        if (!societyIdStr || typeof societyIdStr === 'string' && societyIdStr.trim() === '') {
            return {
                isValid: false,
                id: societyIdStr,
                fallback: societyIdStr,
                error: 'Society ID cannot be empty'
            };
        }
        // Preserve original format for database lookup
        const id = societyIdStr;
        // Extract fallback ID (remove S- prefix if present)
        let fallback = societyIdStr;
        if (societyIdStr.startsWith('S-')) {
            fallback = societyIdStr.substring(2);
        }
        // Try to parse numeric ID for fallback matching
        let numericId;
        const numericPart = parseInt(fallback);
        if (!isNaN(numericPart)) {
            numericId = numericPart;
        }
        return {
            isValid: true,
            id,
            fallback,
            numericId
        };
    }
    /**
   * Validate and parse machine ID (handles M prefix format with optional letter)
   * 
   * Supports multiple formats:
   * - M00001 -> 1 (numeric)
   * - Mm00001 -> m1 (alphanumeric with letter)
   * - Ma00005 -> a5 (alphanumeric with letter)
   * - M0000df -> df (fully alphanumeric)
   * 
   * @param machineId - Machine ID with M prefix
   * @returns Validation result with parsed IDs and variants
   */ static validateMachineId(machineId) {
        if (!machineId || machineId.trim() === '') {
            return {
                isValid: false,
                error: 'Machine ID is required but not provided'
            };
        }
        // Validate machine ID format (must start with M)
        if (!machineId.startsWith('M') || machineId.length < 2) {
            return {
                isValid: false,
                error: `Invalid machine ID format: "${machineId}"`
            };
        }
        // Remove first 'M' prefix and extract actual machine ID
        // Format: M + optional_letter + numbers
        // Examples: Mm00001 -> m00001, M00001 -> 00001, Ma00005 -> a00005
        const withoutPrefix = machineId.substring(1);
        // Validate that remaining part is alphanumeric
        if (!/^[a-zA-Z0-9]+$/.test(withoutPrefix)) {
            return {
                isValid: false,
                error: `Invalid machine ID format: "${machineId}" - contains invalid characters`
            };
        }
        let processedId;
        let isNumeric = false;
        let numericId;
        let alphanumericId;
        // Check if withoutPrefix contains any letters
        const hasLetters = /[a-zA-Z]/.test(withoutPrefix);
        if (hasLetters) {
            // Contains letters - treat as alphanumeric
            // Examples: m00001, 000m1, 0000df, abc123
            const strippedId = withoutPrefix.replace(/^0+/, '') || withoutPrefix;
            // Check if it starts with a letter after removing zeros
            if (/^[a-zA-Z]/.test(strippedId)) {
                const letter = strippedId.charAt(0).toLowerCase();
                const remainingPart = strippedId.substring(1);
                // Check if remaining part is numeric
                if (/^\d+$/.test(remainingPart)) {
                    // Letter + numbers: m00001 -> m1, 000m1 -> m1
                    const cleanedNumber = remainingPart.replace(/^0+/, '') || '0';
                    processedId = letter + cleanedNumber;
                    alphanumericId = processedId;
                } else {
                    // Mixed alphanumeric: df, abc123
                    processedId = strippedId;
                    alphanumericId = processedId;
                }
            } else {
                // Starts with number but has letters: should not happen after strip
                processedId = strippedId;
                alphanumericId = processedId;
            }
        } else {
            // No letter, just numbers (e.g., 00001 -> 1)
            processedId = withoutPrefix.replace(/^0+/, '') || '0';
            const parsed = parseInt(processedId);
            if (!isNaN(parsed) && parsed > 0) {
                isNumeric = true;
                numericId = parsed;
            } else {
                return {
                    isValid: false,
                    error: `Invalid machine ID: "${machineId}" - invalid numeric format`
                };
            }
        }
        console.log(`ðŸ”„ Machine ID conversion: "${machineId}" -> "${withoutPrefix}" -> "${processedId}"`);
        // Create variants for flexible database matching
        const variants = [];
        if (isNumeric && numericId) {
            // Numeric ID variants
            variants.push(numericId); // Numeric: 1
            variants.push(machineId); // Original: M00001
            variants.push(withoutPrefix); // Without M: 00001
            variants.push(processedId); // Stripped: 1
            variants.push(String(numericId)); // String numeric: "1"
        } else if (alphanumericId) {
            // Alphanumeric ID variants
            variants.push(alphanumericId); // Processed: m1, df
            variants.push(withoutPrefix); // Without M: m00001, 0000df
            // Add stripped version if different
            const strippedVersion = withoutPrefix.replace(/^0+/, '');
            if (strippedVersion && strippedVersion !== alphanumericId && strippedVersion !== withoutPrefix) {
                variants.push(strippedVersion);
            }
        }
        return {
            isValid: true,
            numericId,
            alphanumericId,
            withoutPrefix,
            strippedId: processedId,
            variants,
            isNumeric
        };
    }
    /**
   * Validate DB Key format
   */ static validateDbKey(dbKey) {
        if (!dbKey || dbKey.trim() === '') {
            return {
                isValid: false,
                error: 'DB Key is required'
            };
        }
        // Add additional DB key format validation if needed
        if (dbKey.length < 2) {
            return {
                isValid: false,
                error: 'DB Key must be at least 2 characters'
            };
        }
        return {
            isValid: true
        };
    }
    /**
   * Validate machine model/type (basic validation)
   */ static validateMachineModel(machineModel) {
        if (!machineModel || machineModel.trim() === '') {
            return {
                isValid: true,
                warning: `Machine model is empty: "${machineModel}"`
            };
        }
        return {
            isValid: true
        };
    }
    /**
   * Validate password type for machine password endpoints
   */ static validatePasswordType(passwordType) {
        if (!passwordType) {
            return {
                isValid: false,
                isUser: false,
                isSupervisor: false,
                error: 'Password type is required'
            };
        }
        // Accept both full formats (U$0D, S$0D) and short formats (U, S)
        const isUser = passwordType.startsWith('U');
        const isSupervisor = passwordType.startsWith('S');
        if (!isUser && !isSupervisor) {
            return {
                isValid: false,
                isUser: false,
                isSupervisor: false,
                error: `Invalid password type: "${passwordType}"`
            };
        }
        return {
            isValid: true,
            isUser,
            isSupervisor
        };
    }
}
}),
"[project]/src/lib/external-api/QueryBuilder.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Utility class for building database queries for external APIs
 */ __turbopack_context__.s([
    "QueryBuilder",
    ()=>QueryBuilder
]);
class QueryBuilder {
    /**
   * Build society filter conditions for WHERE clause
   */ static buildSocietyFilter(societyId, fallbackId, numericId) {
        // Support multiple society ID formats:
        // 1. String matching (s.society_id = 'S-s12')
        // 2. Fallback string matching (s.society_id = 's12') 
        // 3. Numeric matching (m.society_id = 12)
        const condition = '(s.society_id = ? OR s.society_id = ? OR m.society_id = ?)';
        const societyIdNumeric = numericId || fallbackId;
        return {
            condition,
            replacements: [
                societyId,
                fallbackId,
                societyIdNumeric
            ]
        };
    }
    /**
   * Build machine filter conditions for WHERE clause
   * Supports both numeric and alphanumeric machine IDs
   * 
   * @param machineValidation - Result from InputValidator.validateMachineId()
   * @param useNumericId - Whether to use numeric ID (m.id) or string ID (m.machine_id)
   */ static buildMachineFilter(machineValidation, useNumericId = true) {
        // For numeric machine IDs (backward compatibility)
        if (machineValidation.isNumeric && machineValidation.numericId && useNumericId) {
            // Direct numeric ID matching: m.id = 1
            return {
                condition: 'm.id = ?',
                replacements: [
                    machineValidation.numericId
                ]
            };
        }
        // For alphanumeric machine IDs or string-based matching
        if (machineValidation.variants && machineValidation.variants.length > 0) {
            // Use IN clause with all variants
            const placeholders = machineValidation.variants.map(()=>'?').join(', ');
            return {
                condition: `m.machine_id IN (${placeholders})`,
                replacements: machineValidation.variants
            };
        }
        // Fallback to direct alphanumeric matching
        if (machineValidation.alphanumericId) {
            return {
                condition: 'm.machine_id = ?',
                replacements: [
                    machineValidation.alphanumericId
                ]
            };
        }
        // Final fallback - should not reach here if validation passed
        throw new Error('Invalid machine validation result for query building');
    }
    /**
   * Build base query with schema, table, and joins
   */ static buildBaseQuery(schemaName, tableName) {
        const escapedSchema = QueryBuilder.escapeIdentifier(schemaName);
        if (tableName === 'farmers') {
            return `
        FROM ${escapedSchema}.farmers f
        LEFT JOIN ${escapedSchema}.societies s ON f.society_id = s.id
        LEFT JOIN ${escapedSchema}.machines m ON f.machine_id = m.id
      `;
        } else if (tableName === 'machines') {
            return `
        FROM ${escapedSchema}.machines m
        LEFT JOIN ${escapedSchema}.societies s ON m.society_id = s.id
      `;
        } else {
            throw new Error(`Unsupported table name: ${tableName}`);
        }
    }
    /**
   * Build complete SELECT query for farmer info
   */ static buildFarmerQuery(schemaName, societyFilter, machineFilter, pagination) {
        const baseQuery = QueryBuilder.buildBaseQuery(schemaName, 'farmers');
        let query = `
      SELECT 
        f.id, 
        f.farmer_id,
        f.rf_id, 
        f.name, 
        f.phone, 
        f.sms_enabled, 
        f.bonus
      ${baseQuery}
      WHERE ${societyFilter.condition}
        AND f.status = 'active'
        AND ${machineFilter.condition}
      ORDER BY f.farmer_id
    `;
        let replacements = [
            ...societyFilter.replacements,
            ...machineFilter.replacements
        ];
        if (pagination) {
            query += ' LIMIT ? OFFSET ?';
            replacements = [
                ...replacements,
                pagination.limit,
                pagination.offset
            ];
        }
        return {
            query,
            replacements
        };
    }
    /**
   * Build complete SELECT query for machine password
   */ static buildMachinePasswordQuery(schemaName, societyFilter, machineFilter) {
        const baseQuery = QueryBuilder.buildBaseQuery(schemaName, 'machines');
        const query = `
      SELECT 
        m.id, 
        m.machine_id, 
        m.user_password, 
        m.supervisor_password, 
        m.statusU, 
        m.statusS,
        s.society_id as society_string_id
      ${baseQuery}
      WHERE ${societyFilter.condition}
        AND ${machineFilter.condition}
        AND m.status = 'active'
    `;
        const replacements = [
            ...societyFilter.replacements,
            ...machineFilter.replacements
        ];
        return {
            query,
            replacements
        };
    }
    /**
   * Build society lookup query to get database ID from society_id string
   */ static buildSocietyLookupQuery(schemaName, societyIdStr) {
        const escapedSchema = QueryBuilder.escapeIdentifier(schemaName);
        // Try both with and without S- prefix
        const lookupParams = societyIdStr.startsWith('S-') ? [
            societyIdStr,
            societyIdStr.substring(2)
        ] : [
            `S-${societyIdStr}`,
            societyIdStr
        ];
        const query = `
      SELECT id FROM ${escapedSchema}.societies 
      WHERE society_id = ? OR society_id = ?
      LIMIT 1
    `;
        return {
            query,
            replacements: lookupParams
        };
    }
    /**
   * Safely escape database identifiers (schema/table names)
   */ static escapeIdentifier(identifier) {
        // Remove any non-alphanumeric characters except underscores
        const cleaned = identifier.replace(/[^a-zA-Z0-9_]/g, '');
        return `\`${cleaned}\``;
    }
    /**
   * Build pagination parameters
   */ static buildPagination(pageNumber, pageSize = 5) {
        const normalizedPageNumber = Math.max(1, pageNumber);
        const offset = (normalizedPageNumber - 1) * pageSize;
        return {
            limit: pageSize,
            offset,
            pageNumber: normalizedPageNumber
        };
    }
    /**
   * Extract page number from C parameter format (C00001 = page 1, C00002 = page 2)
   */ static parsePageNumber(lengthParam) {
        if (!lengthParam || !lengthParam.startsWith('C')) {
            return 1;
        }
        const pageNumber = parseInt(lengthParam.replace(/^C0*/, '')) || 1;
        return Math.max(1, pageNumber);
    }
}
}),
"[project]/src/lib/external-api/ResponseFormatter.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Response formatting utilities for external APIs
 */ __turbopack_context__.s([
    "ResponseFormatter",
    ()=>ResponseFormatter
]);
class ResponseFormatter {
    /**
   * Format farmer data for CSV download
   */ static formatFarmerCSV(farmers) {
        const csvHeader = 'ID,RF-ID,NAME,MOBILE,SMS,BONUS\n';
        const csvData = farmers.map((farmer)=>{
            const phone = farmer.phone || '';
            const smsEnabled = farmer.sms_enabled || 'OFF';
            // Convert bonus to number and format without decimal places (matching sample format)
            let bonus = '0';
            if (farmer.bonus !== null && farmer.bonus !== undefined) {
                const bonusNum = Number(farmer.bonus);
                bonus = isNaN(bonusNum) ? '0' : Math.round(bonusNum).toString();
            }
            // Escape CSV values that contain commas or quotes
            const escapeCsv = (value)=>{
                if (value.includes(',') || value.includes('"')) {
                    return `"${value.replace(/"/g, '""')}"`;
                }
                return value;
            };
            return `${farmer.id},${escapeCsv(farmer.farmer_id)},${escapeCsv(farmer.name)},${escapeCsv(phone)},${smsEnabled},${bonus}`;
        }).join('\n');
        return csvHeader + csvData;
    }
    /**
   * Format farmer data for pagination response (pipe-delimited)
   */ static formatFarmerPagination(farmers) {
        // Format: id|farmer_id|name|phone|sms_enabled|bonus||
        // Each farmer separated by ||, fields separated by |
        const responseData = farmers.map((farmer)=>{
            const phone = farmer.phone || '';
            const smsEnabled = farmer.sms_enabled || 'OFF';
            // Convert bonus to number and format with 2 decimal places
            let bonus = '0.00';
            if (farmer.bonus !== null && farmer.bonus !== undefined) {
                const bonusNum = Number(farmer.bonus);
                bonus = isNaN(bonusNum) ? '0.00' : bonusNum.toFixed(2);
            }
            return `${farmer.id}|${farmer.farmer_id}|${farmer.name}|${phone}|${smsEnabled}|${bonus}`;
        }).join('||');
        return responseData;
    }
    /**
   * Format machine password response
   */ static formatMachinePassword(passwordType, password) {
        if (passwordType.isUser) {
            return `PU|${password}`;
        } else if (passwordType.isSupervisor) {
            return `PS|${password}`;
        }
        throw new Error('Invalid password type for formatting');
    }
    /**
   * Create standard success response with proper headers
   */ static createSuccessResponse(data, contentType = 'text/plain', additionalHeaders) {
        const headers = {
            'Content-Type': contentType,
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST',
            'Access-Control-Allow-Headers': 'Content-Type',
            ...additionalHeaders
        };
        // Add CSV-specific headers
        if (contentType === 'text/csv') {
            headers['Content-Disposition'] = 'attachment; filename="FarmerDetails.csv"';
        }
        return new Response(`"${data}"`, {
            status: 200,
            headers
        });
    }
    /**
   * Create standard error response
   */ static createErrorResponse(errorMessage) {
        return new Response(`"${errorMessage}"`, {
            status: 200,
            headers: {
                'Content-Type': 'text/plain'
            }
        });
    }
    /**
   * Create CORS preflight response
   */ static createCORSResponse() {
        return new Response(null, {
            status: 200,
            headers: {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        });
    }
    /**
   * Wrap response data in quotes (external API standard)
   */ static wrapInQuotes(data) {
        return `"${data}"`;
    }
    /**
   * Log response details for debugging
   */ static logResponse(endpointName, dataType, itemCount, responsePreview) {
        console.log(`ðŸ“¤ ${endpointName}: Returning ${dataType} for ${itemCount} items`);
        if (responsePreview) {
            const preview = responsePreview.length > 100 ? `${responsePreview.substring(0, 100)}...` : responsePreview;
            console.log(`ðŸ“¤ Response preview: ${preview}`);
        }
    }
    /**
   * Log CSV response details
   */ static logCSVResponse(endpointName, itemCount, csvSize) {
        console.log(`ðŸ“ ${endpointName}: Returning CSV data for ${itemCount} items`);
        console.log(`ðŸ“ CSV size: ${csvSize} characters`);
    }
}
}),
"[project]/src/lib/external-api/ESP32ResponseHelper.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * ESP32-Friendly Response Helper
 * 
 * Utilities for creating responses compatible with ESP32 WiFi modules
 * 
 * Key Requirements:
 * - Always return HTTP 200 status (even for errors)
 * - No quotes around response text for simple messages
 * - Specific headers: charset=utf-8, Content-Length, Connection: close
 * - Cache-Control: no-cache for fresh data
 */ __turbopack_context__.s([
    "ESP32ResponseHelper",
    ()=>ESP32ResponseHelper
]);
class ESP32ResponseHelper {
    /**
   * Create ESP32-friendly success response
   * @param data - Response data (will be quoted by default)
   * @param options - Additional options
   */ static createResponse(data, options) {
        const { contentType = 'text/plain; charset=utf-8', addQuotes = true, additionalHeaders = {} } = options || {};
        // Wrap response in double quotes by default for ESP32 compatibility
        const responseBody = addQuotes ? `"${data}"` : data;
        const contentLength = Buffer.byteLength(responseBody, 'utf8');
        return new Response(responseBody, {
            status: 200,
            headers: {
                'Content-Type': contentType,
                'Content-Length': contentLength.toString(),
                'Connection': 'close',
                'Cache-Control': 'no-cache',
                'Access-Control-Allow-Origin': '*',
                ...additionalHeaders
            }
        });
    }
    /**
   * Create ESP32-friendly error response (still returns 200 status)
   */ static createErrorResponse(errorMessage) {
        return ESP32ResponseHelper.createResponse(errorMessage);
    }
    /**
   * Create success response with structured data (pipe-delimited format)
   */ static createDataResponse(data) {
        return ESP32ResponseHelper.createResponse(data, {
            additionalHeaders: {
                'Access-Control-Allow-Methods': 'GET, POST',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        });
    }
    /**
   * Create CSV response with proper headers
   */ static createCSVResponse(csvData, filename = 'data.csv') {
        return new Response(csvData, {
            status: 200,
            headers: {
                'Content-Type': 'text/csv; charset=utf-8',
                'Content-Disposition': `attachment; filename="${filename}"`,
                'Content-Length': Buffer.byteLength(csvData, 'utf8').toString(),
                'Connection': 'close',
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        });
    }
    /**
   * Create CORS preflight response
   */ static createCORSResponse() {
        return new Response(null, {
            status: 200,
            headers: {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        });
    }
    /**
   * Extract InputString from request (handles malformed URLs from ESP32)
   */ static async extractInputString(request) {
        let inputString = null;
        if (request.method === 'GET') {
            const { searchParams } = new URL(request.url);
            inputString = searchParams.get('InputString');
            // Handle malformed URLs from ESP32 (e.g., "?,InputString=...")
            if (!inputString) {
                // Check if any param key contains "InputString" (handles ",InputString" case)
                for (const [key, value] of searchParams.entries()){
                    if (key.includes('InputString')) {
                        inputString = value;
                        console.log(`   âœ… ESP32: Found InputString in malformed param key: "${key}"`);
                        break;
                    }
                }
            }
        } else if (request.method === 'POST') {
            try {
                const body = await request.json();
                inputString = body.InputString || null;
            } catch  {
                try {
                    const formData = await request.formData();
                    inputString = formData.get('InputString') || null;
                } catch (error) {
                    console.log(`âŒ ESP32: Failed to parse POST body:`, error);
                }
            }
        }
        return inputString;
    }
    /**
   * Filter line ending characters from InputString
   * ESP32 sends $0D, $0A, $0D$0A patterns
   */ static filterLineEndings(inputString) {
        if (!inputString) return inputString;
        const original = inputString;
        // Remove common line ending patterns
        const filtered = inputString.replace(/\$0D\$0A/g, '') // CRLF
        .replace(/\$0D/g, '') // CR
        .replace(/\$0A/g, '') // LF
        .replace(/\r\n/g, '') // Actual CRLF
        .replace(/\r/g, '') // Actual CR
        .replace(/\n/g, ''); // Actual LF
        if (original !== filtered) {
            console.log(`ðŸ§¹ ESP32: Filtered line endings: "${original}" -> "${filtered}"`);
        }
        return filtered;
    }
    /**
   * Log ESP32 request details for debugging
   */ static logRequest(request, dbKey, inputString) {
        console.log(`\n${'='.repeat(80)}`);
        console.log(`ðŸ“¡ ESP32 External API Request:`);
        console.log(`   Timestamp: ${new Date().toISOString()}`);
        console.log(`   Method: ${request.method}`);
        console.log(`   Full URL: ${request.url}`);
        console.log(`   DB Key: "${dbKey}"`);
        console.log(`   InputString: "${inputString}"`);
        console.log(`   Headers:`, {
            'user-agent': request.headers.get('user-agent'),
            'content-type': request.headers.get('content-type'),
            'connection': request.headers.get('connection'),
            'host': request.headers.get('host')
        });
        console.log(`${'='.repeat(80)}\n`);
    }
}
}),
"[project]/src/lib/external-api/index.ts [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// External API pattern base classes and utilities
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$BaseExternalAPI$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/BaseExternalAPI.ts [app-route] (ecmascript)");
// Input validation utilities
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$InputValidator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/InputValidator.ts [app-route] (ecmascript)");
// Database query building utilities
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$QueryBuilder$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/QueryBuilder.ts [app-route] (ecmascript)");
// Response formatting utilities  
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ResponseFormatter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/ResponseFormatter.ts [app-route] (ecmascript)");
// ESP32-specific response utilities
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/ESP32ResponseHelper.ts [app-route] (ecmascript)");
;
;
;
;
;
}),
"[project]/src/lib/sectionPulseTracker.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SectionPulseTracker",
    ()=>SectionPulseTracker
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sequelize/lib/index.mjs [app-route] (ecmascript)");
;
class SectionPulseTracker {
    /**
   * Update pulse on new milk collection
   * - Records first collection time (section start pulse)
   * - Updates last collection time
   * - Increments total collections counter (only for new collections)
   * 
   * @param sequelize Sequelize instance
   * @param schemaName Admin schema name
   * @param societyId Society database ID
   * @param collectionDateTime Collection datetime (YYYY-MM-DD HH:MM:SS)
   * @param isNewCollection Whether this is a new collection (not a duplicate update)
   */ static async updatePulseOnCollection(sequelize, schemaName, societyId, collectionDateTime, isNewCollection = true) {
        try {
            // Parse collection datetime - handle both string and Date
            // Store as string to preserve IST timezone when passing to MySQL
            let collectionDateStr;
            let dateStr;
            if (typeof collectionDateTime === 'string') {
                // If it's a string like "2025-12-02 01:00:26", use it directly
                collectionDateStr = collectionDateTime;
                dateStr = collectionDateTime.split(' ')[0]; // Get "2025-12-02"
            } else {
                // Convert Date to IST string format: YYYY-MM-DD HH:MM:SS
                const offset = 5.5 * 60 * 60 * 1000; // IST offset in milliseconds
                const istDate = new Date(collectionDateTime.getTime() + offset);
                collectionDateStr = istDate.toISOString().slice(0, 19).replace('T', ' ');
                dateStr = collectionDateStr.split(' ')[0];
            }
            console.log(`ðŸ“ Updating pulse for society ${societyId} on ${dateStr} at ${collectionDateStr}`);
            console.log(`   ðŸ”¢ isNewCollection flag: ${isNewCollection} (will ${isNewCollection ? 'INCREMENT' : 'NOT INCREMENT'} total_collections)`);
            // Check if pulse record exists for today
            const existingPulse = await sequelize.query(`
        SELECT id, first_collection_time, total_collections, pulse_status
        FROM \`${schemaName}\`.section_pulse
        WHERE society_id = ? AND DATE(pulse_date) = ?
      `, {
                replacements: [
                    societyId,
                    dateStr
                ],
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QueryTypes"].SELECT
            });
            console.log(`ðŸ” Query result:`, {
                length: existingPulse?.length,
                data: existingPulse
            });
            if (!existingPulse || existingPulse.length === 0) {
                // First collection of the day - create new pulse record
                await sequelize.query(`
          INSERT INTO \`${schemaName}\`.section_pulse (
            society_id,
            pulse_date,
            first_collection_time,
            last_collection_time,
            pulse_status,
            total_collections,
            inactive_days,
            last_checked,
            created_at,
            updated_at
          ) VALUES (?, ?, ?, ?, 'active', 1, 0, NOW(), CONVERT_TZ(NOW(), '+00:00', '+05:30'), CONVERT_TZ(NOW(), '+00:00', '+05:30'))
        `, {
                    replacements: [
                        societyId,
                        dateStr,
                        collectionDateStr,
                        collectionDateStr
                    ]
                });
                console.log(`ðŸŸ¢ Section start pulse recorded at ${collectionDateStr}`);
            } else {
                // Update existing pulse record - restart if paused or ended
                const currentStatus = existingPulse[0].pulse_status;
                // Only increment total_collections if this is a new collection (not a duplicate update)
                const updateQuery = isNewCollection ? `UPDATE \`${schemaName}\`.section_pulse
             SET 
               last_collection_time = ?,
               total_collections = total_collections + 1,
               pulse_status = 'active',
               section_end_time = NULL,
               last_checked = NOW(),
               updated_at = CONVERT_TZ(NOW(), '+00:00', '+05:30')
             WHERE society_id = ? AND DATE(pulse_date) = ?` : `UPDATE \`${schemaName}\`.section_pulse
             SET 
               last_collection_time = ?,
               pulse_status = 'active',
               section_end_time = NULL,
               last_checked = NOW(),
               updated_at = CONVERT_TZ(NOW(), '+00:00', '+05:30')
             WHERE society_id = ? AND DATE(pulse_date) = ?`;
                await sequelize.query(updateQuery, {
                    replacements: [
                        collectionDateStr,
                        societyId,
                        dateStr
                    ]
                });
                if (currentStatus === 'paused') {
                    console.log(`â–¶ï¸ Section restarted from pause - collection at ${collectionDateStr}`);
                } else if (currentStatus === 'ended') {
                    console.log(`ðŸ”„ Section restarted from ended state - collection at ${collectionDateStr}`);
                } else {
                    console.log(`ðŸ”µ Pulse updated - last collection at ${collectionDateStr}${isNewCollection ? '' : ' (duplicate, count unchanged)'}`);
                }
            }
            // Reset inactive days counter since we have activity
            await this.resetInactiveDays(sequelize, schemaName, societyId, dateStr);
        } catch (error) {
            console.error('âŒ Error updating pulse on collection:', error);
            throw error;
        }
    }
    /**
   * Check for section pause (5 minutes of inactivity) and section end (60 minutes)
   * Should be called periodically (e.g., every 1-2 minutes)
   * 
   * @param sequelize Sequelize instance
   * @param schemaName Admin schema name
   */ static async checkSectionPauseAndEnd(sequelize, schemaName) {
        try {
            const now = new Date();
            const today = now.toISOString().split('T')[0];
            const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);
            const sixtyMinutesAgo = new Date(now.getTime() - 60 * 60 * 1000);
            // 1. End all active/paused sections from previous days
            const [oldPulses] = await sequelize.query(`
        SELECT id, society_id, pulse_date, last_collection_time
        FROM \`${schemaName}\`.section_pulse
        WHERE pulse_status IN ('active', 'paused')
        AND DATE(pulse_date) < ?
        AND section_end_time IS NULL
      `, {
                replacements: [
                    today
                ],
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QueryTypes"].SELECT
            });
            // Mark old sections as ended
            for (const pulse of oldPulses || []){
                const sectionEndTime = pulse.last_collection_time ? new Date(new Date(pulse.last_collection_time).getTime() + 60 * 60 * 1000) : null;
                await sequelize.query(`
          UPDATE \`${schemaName}\`.section_pulse
          SET 
            section_end_time = ?,
            pulse_status = 'ended',
            last_checked = NOW(),
            updated_at = CONVERT_TZ(NOW(), '+00:00', '+05:30')
          WHERE id = ?
        `, {
                    replacements: [
                        sectionEndTime,
                        pulse.id
                    ]
                });
                console.log(`ðŸ”´ Old section ended for society ${pulse.society_id} (date: ${pulse.pulse_date})`);
            }
            // 2. Check for sections to pause (5 minutes inactive, currently active, TODAY only)
            const [activePulses] = await sequelize.query(`
        SELECT id, society_id, pulse_date, last_collection_time
        FROM \`${schemaName}\`.section_pulse
        WHERE pulse_status = 'active'
        AND DATE(pulse_date) = ?
        AND last_collection_time IS NOT NULL
        AND last_collection_time <= ?
        AND last_collection_time > ?
      `, {
                replacements: [
                    today,
                    fiveMinutesAgo,
                    sixtyMinutesAgo
                ],
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QueryTypes"].SELECT
            });
            // Mark sections as paused
            for (const pulse of activePulses || []){
                await sequelize.query(`
          UPDATE \`${schemaName}\`.section_pulse
          SET 
            pulse_status = 'paused',
            last_checked = NOW(),
            updated_at = CONVERT_TZ(NOW(), '+00:00', '+05:30')
          WHERE id = ?
        `, {
                    replacements: [
                        pulse.id
                    ]
                });
                console.log(`â¸ï¸ Section paused for society ${pulse.society_id} - no collection for 5 minutes`);
            }
            // 3. Check for sections to end (60 minutes inactive, currently active or paused, TODAY only)
            const [inactivePulses] = await sequelize.query(`
        SELECT id, society_id, pulse_date, last_collection_time
        FROM \`${schemaName}\`.section_pulse
        WHERE pulse_status IN ('active', 'paused')
        AND DATE(pulse_date) = ?
        AND last_collection_time IS NOT NULL
        AND last_collection_time <= ?
        AND section_end_time IS NULL
      `, {
                replacements: [
                    today,
                    sixtyMinutesAgo
                ],
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QueryTypes"].SELECT
            });
            // Mark sections as ended
            for (const pulse of inactivePulses || []){
                const sectionEndTime = new Date(pulse.last_collection_time.getTime() + 60 * 60 * 1000);
                await sequelize.query(`
          UPDATE \`${schemaName}\`.section_pulse
          SET 
            section_end_time = ?,
            pulse_status = 'ended',
            last_checked = CONVERT_TZ(NOW(), '+00:00', '+05:30'),
            updated_at = CONVERT_TZ(NOW(), '+00:00', '+05:30')
          WHERE id = ?
        `, {
                    replacements: [
                        sectionEndTime,
                        pulse.id
                    ]
                });
                console.log(`ðŸ”´ Section end pulse recorded for society ${pulse.society_id} at ${sectionEndTime.toISOString()}`);
            }
        } catch (error) {
            console.error('âŒ Error checking section pause and end:', error);
            throw error;
        }
    }
    /**
   * Check for section end (60 minutes of inactivity after last collection)
   * Should be called periodically (e.g., every 10-15 minutes)
   * 
   * @deprecated Use checkSectionPauseAndEnd instead for better granularity
   * @param sequelize Sequelize instance
   * @param schemaName Admin schema name
   */ static async checkSectionEnd(sequelize, schemaName) {
        try {
            const now = new Date();
            const sixtyMinutesAgo = new Date(now.getTime() - 60 * 60 * 1000);
            // Find active pulses where last collection was > 60 minutes ago
            const [activePulses] = await sequelize.query(`
        SELECT id, society_id, pulse_date, last_collection_time
        FROM \`${schemaName}\`.section_pulse
        WHERE pulse_status = 'active'
        AND last_collection_time IS NOT NULL
        AND last_collection_time <= ?
        AND section_end_time IS NULL
      `, {
                replacements: [
                    sixtyMinutesAgo
                ],
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QueryTypes"].SELECT
            });
            for (const pulse of activePulses || []){
                const sectionEndTime = new Date(pulse.last_collection_time.getTime() + 60 * 60 * 1000);
                await sequelize.query(`
          UPDATE \`${schemaName}\`.section_pulse
          SET 
            section_end_time = ?,
            pulse_status = 'ended',
            last_checked = CONVERT_TZ(NOW(), '+00:00', '+05:30'),
            updated_at = CONVERT_TZ(NOW(), '+00:00', '+05:30')
          WHERE id = ?
        `, {
                    replacements: [
                        sectionEndTime,
                        pulse.id
                    ]
                });
                console.log(`ðŸ”´ Section end pulse recorded for society ${pulse.society_id} at ${sectionEndTime.toISOString()}`);
            }
        } catch (error) {
            console.error('âŒ Error checking section end:', error);
            throw error;
        }
    }
    /**
   * Check for multi-day inactivity
   * Updates inactive_days counter for societies without collections
   * 
   * @param sequelize Sequelize instance
   * @param schemaName Admin schema name
   */ static async checkInactivity(sequelize, schemaName) {
        try {
            const today = new Date().toISOString().split('T')[0];
            const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            // Get all societies
            const [societies] = await sequelize.query(`
        SELECT id FROM \`${schemaName}\`.societies
        WHERE status = 'active'
      `, {
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QueryTypes"].SELECT
            });
            for (const society of societies || []){
                // Check if society has pulse record for today
                const [todayPulse] = await sequelize.query(`
          SELECT id FROM \`${schemaName}\`.section_pulse
          WHERE society_id = ? AND DATE(pulse_date) = ?
        `, {
                    replacements: [
                        society.id,
                        today
                    ],
                    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QueryTypes"].SELECT
                });
                if (!todayPulse || todayPulse.length === 0) {
                    // No pulse today - check yesterday's pulse
                    const [yesterdayPulse] = await sequelize.query(`
            SELECT inactive_days, pulse_status
            FROM \`${schemaName}\`.section_pulse
            WHERE society_id = ? AND DATE(pulse_date) = ?
          `, {
                        replacements: [
                            society.id,
                            yesterday
                        ],
                        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QueryTypes"].SELECT
                    });
                    let inactiveDays = 1;
                    if (yesterdayPulse && yesterdayPulse.length > 0) {
                        inactiveDays = (yesterdayPulse[0].inactive_days || 0) + 1;
                    }
                    // Create today's pulse record with inactive status
                    await sequelize.query(`
            INSERT INTO \`${schemaName}\`.section_pulse (
              society_id,
              pulse_date,
              pulse_status,
              inactive_days,
              last_checked,
              created_at,
              updated_at
            ) VALUES (?, ?, 'inactive', ?, NOW(), CONVERT_TZ(NOW(), '+00:00', '+05:30'), CONVERT_TZ(NOW(), '+00:00', '+05:30'))
            ON DUPLICATE KEY UPDATE
              pulse_status = 'inactive',
              inactive_days = ?,
              last_checked = NOW(),
              updated_at = CONVERT_TZ(NOW(), '+00:00', '+05:30')
          `, {
                        replacements: [
                            society.id,
                            today,
                            inactiveDays,
                            inactiveDays
                        ]
                    });
                    console.log(`âšª No pulse for society ${society.id} - ${inactiveDays} day(s) inactive`);
                }
            }
        } catch (error) {
            console.error('âŒ Error checking inactivity:', error);
            throw error;
        }
    }
    /**
   * Reset inactive days counter
   */ static async resetInactiveDays(sequelize, schemaName, societyId, pulseDate) {
        await sequelize.query(`
      UPDATE \`${schemaName}\`.section_pulse
      SET inactive_days = 0
      WHERE society_id = ? AND DATE(pulse_date) = ?
    `, {
            replacements: [
                societyId,
                pulseDate
            ]
        });
    }
    /**
   * Get pulse status for a society
   * 
   * @param sequelize Sequelize instance
   * @param schemaName Admin schema name
   * @param societyId Society database ID
   * @param date Date string (YYYY-MM-DD) - defaults to today
   */ static async getPulseStatus(sequelize, schemaName, societyId, date) {
        try {
            const pulseDate = date || new Date().toISOString().split('T')[0];
            const pulseRecords = await sequelize.query(`
        SELECT 
          society_id,
          pulse_date,
          first_collection_time,
          last_collection_time,
          section_end_time,
          pulse_status,
          total_collections,
          inactive_days,
          created_at
        FROM \`${schemaName}\`.section_pulse
        WHERE society_id = ? AND DATE(pulse_date) = ?
      `, {
                replacements: [
                    societyId,
                    pulseDate
                ],
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QueryTypes"].SELECT
            });
            if (!pulseRecords || pulseRecords.length === 0) {
                // No pulse record exists - section not started
                return {
                    societyId,
                    pulseDate,
                    firstCollectionTime: null,
                    lastCollectionTime: null,
                    sectionEndTime: null,
                    pulseStatus: 'not_started',
                    totalCollections: 0,
                    inactiveDays: 0,
                    createdAt: null
                };
            }
            const pulse = pulseRecords[0];
            return {
                societyId: pulse.society_id,
                pulseDate: pulse.pulse_date,
                firstCollectionTime: pulse.first_collection_time,
                lastCollectionTime: pulse.last_collection_time,
                sectionEndTime: pulse.section_end_time,
                pulseStatus: pulse.pulse_status,
                totalCollections: pulse.total_collections,
                inactiveDays: pulse.inactive_days,
                createdAt: pulse.created_at
            };
        } catch (error) {
            console.error('âŒ Error getting pulse status:', error);
            throw error;
        }
    }
    /**
   * Get pulse status for all societies
   * 
   * @param sequelize Sequelize instance
   * @param schemaName Admin schema name
   * @param date Date string (YYYY-MM-DD) - defaults to today
   */ static async getAllPulseStatuses(sequelize, schemaName, date) {
        try {
            const pulseDate = date || new Date().toISOString().split('T')[0];
            const pulseRecords = await sequelize.query(`
        SELECT 
          s.id as society_id,
          s.name as society_name,
          COALESCE(sp.pulse_date, ?) as pulse_date,
          sp.first_collection_time,
          sp.last_collection_time,
          sp.section_end_time,
          COALESCE(sp.pulse_status, 'not_started') as pulse_status,
          COALESCE(sp.total_collections, 0) as total_collections,
          COALESCE(sp.inactive_days, 0) as inactive_days,
          sp.created_at
        FROM \`${schemaName}\`.societies s
        LEFT JOIN \`${schemaName}\`.section_pulse sp 
          ON s.id = sp.society_id AND DATE(sp.pulse_date) = ?
        WHERE s.status = 'active'
        ORDER BY s.name
      `, {
                replacements: [
                    pulseDate,
                    pulseDate
                ],
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["QueryTypes"].SELECT
            });
            return (pulseRecords || []).map((pulse)=>({
                    societyId: pulse.society_id,
                    pulseDate: pulse.pulse_date,
                    firstCollectionTime: pulse.first_collection_time,
                    lastCollectionTime: pulse.last_collection_time,
                    sectionEndTime: pulse.section_end_time,
                    pulseStatus: pulse.pulse_status,
                    totalCollections: pulse.total_collections,
                    inactiveDays: pulse.inactive_days,
                    createdAt: pulse.created_at
                }));
        } catch (error) {
            console.error('âŒ Error getting all pulse statuses:', error);
            throw error;
        }
    }
}
}),
"[project]/src/app/api/[db-key]/Collection/SaveCollectionDetails/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET,
    "OPTIONS",
    ()=>OPTIONS,
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/database.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$index$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/src/lib/external-api/index.ts [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/ESP32ResponseHelper.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$InputValidator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/external-api/InputValidator.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sectionPulseTracker$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/sectionPulseTracker.ts [app-route] (ecmascript)");
;
;
;
/**
 * SaveCollectionDetails API Endpoint
 * 
 * Purpose: Save milk collection test data from machines
 * InputString format: societyId|machineType|version|machineId|session|extra|channel|
 *                     F{fat}|S{snf}|C{clr}|P{protein}|L{lactose}|s{salt}|W{water}|T{temp}|
 *                     I{farmerId}|Q{quantity}|R{totalAmount}|r{rate}|i{bonus}|D{datetime}
 * 
 * Example: S-1|LSE-SVPWTBQ-12AH|LE2.00|Mm1|EV|4|COW|F090.70|S07.90|C28.00|P02.90|L04.30|s00.65|W06.00|T26.47|I00005|Q00000.00|R00000.00|r033.60|i10.99|D2025-07-24_02:40:26
 * 
 * Endpoint: GET/POST /api/[db-key]/Collection/SaveCollectionDetails
 */ async function handleRequest(request, { params }) {
    try {
        // Extract InputString using helper
        let inputString = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].extractInputString(request);
        // Await the params Promise in Next.js 15
        const resolvedParams = await params;
        const dbKey = resolvedParams['db-key'] || resolvedParams.dbKey || resolvedParams['dbkey'];
        // Filter line endings from InputString
        if (inputString) {
            inputString = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].filterLineEndings(inputString);
        }
        // Log request
        console.log(`\n${'='.repeat(80)}`);
        console.log(`ðŸ“¡ SaveCollectionDetails API Request:`);
        console.log(`   Timestamp: ${new Date().toISOString()}`);
        __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].logRequest(request, dbKey, inputString);
        // Validate required parameters
        if (!dbKey || dbKey.trim() === '') {
            console.log(`âŒ DB Key validation failed - dbKey: "${dbKey}"`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('DB Key is required');
        }
        if (!inputString) {
            console.log(`âŒ InputString is required`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('InputString parameter is required');
        }
        // Connect to database and validate DB Key
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["connectDB"])();
        const { getModels } = await __turbopack_context__.A("[project]/src/models/index.ts [app-route] (ecmascript, async loader)");
        const { sequelize, User } = getModels();
        // Validate DB key format
        const dbKeyValidation = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$InputValidator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InputValidator"].validateDbKey(dbKey);
        if (!dbKeyValidation.isValid) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse(dbKeyValidation.error || 'Invalid DB Key');
        }
        // Find admin by dbKey to get schema name
        const admin = await User.findOne({
            where: {
                dbKey: dbKey.toUpperCase()
            }
        });
        if (!admin || !admin.dbKey) {
            console.log(`âŒ Admin not found or missing DB Key for: ${dbKey}`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Invalid DB Key');
        }
        // Parse input string - 21 parts expected
        const inputParts = inputString.split('|');
        if (inputParts.length !== 21) {
            console.log(`âŒ Invalid InputString format. Expected 21 parts, got ${inputParts.length}`);
            console.log(`   Parts received:`, inputParts);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Invalid InputString format');
        }
        const [societyIdStr, machineType, version, machineId, session, extra, channel, fatStr, snfStr, clrStr, proteinStr, lactoseStr, saltStr, waterStr, temperatureStr, farmerIdStr, quantityStr, totalAmountStr, rateStr, bonusStr, datetimeStr] = inputParts;
        console.log(`ðŸ” Parsed InputString:`, {
            societyIdStr,
            machineType,
            version,
            machineId,
            session,
            extra,
            channel,
            farmerIdStr,
            datetime: datetimeStr
        });
        // Parse numeric values from formatted strings
        const parseValue = (str, prefix)=>{
            if (!str || !str.startsWith(prefix)) return 0;
            const numStr = str.substring(prefix.length);
            return parseFloat(numStr) || 0;
        };
        const collectionData = {
            societyId: societyIdStr,
            machineType,
            version,
            machineId,
            session,
            extra,
            channel,
            fat: parseValue(fatStr, 'F'),
            snf: parseValue(snfStr, 'S'),
            clr: parseValue(clrStr, 'C'),
            protein: parseValue(proteinStr, 'P'),
            lactose: parseValue(lactoseStr, 'L'),
            salt: parseValue(saltStr, 's'),
            water: parseValue(waterStr, 'W'),
            temperature: parseValue(temperatureStr, 'T'),
            farmerId: farmerIdStr.substring(1).replace(/^0+/, '') || '0',
            quantity: parseValue(quantityStr, 'Q'),
            totalAmount: parseValue(totalAmountStr, 'R'),
            rate: parseValue(rateStr, 'r'),
            bonus: parseValue(bonusStr, 'i'),
            datetime: datetimeStr.substring(1) // Remove 'D' prefix
        };
        console.log(`ðŸ” Parsed collection data:`, collectionData);
        // Validate Society ID
        const societyValidation = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$InputValidator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InputValidator"].validateSocietyId(collectionData.societyId);
        if (!societyValidation.isValid) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Invalid society ID');
        }
        // Validate Machine ID
        const machineValidation = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$InputValidator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InputValidator"].validateMachineId(collectionData.machineId);
        if (!machineValidation.isValid) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Invalid machine ID');
        }
        // Generate schema name
        const cleanAdminName = admin.fullName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
        const schemaName = `${cleanAdminName}_${admin.dbKey.toLowerCase()}`;
        console.log(`ðŸ” Using schema: ${schemaName}`);
        // Look up society
        const societyQuery = `
      SELECT id FROM \`${schemaName}\`.societies 
      WHERE society_id = ? OR society_id = ?
      LIMIT 1
    `;
        const societyLookupParams = societyValidation.id.startsWith('S-') ? [
            societyValidation.id,
            societyValidation.fallback
        ] : [
            `S-${societyValidation.id}`,
            societyValidation.id
        ];
        const [societyResults] = await sequelize.query(societyQuery, {
            replacements: societyLookupParams
        });
        if (!Array.isArray(societyResults) || societyResults.length === 0) {
            console.log(`âŒ Society not found: "${societyValidation.id}"`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Society not found');
        }
        const actualSocietyId = societyResults[0].id;
        console.log(`âœ… Found society: "${societyValidation.id}" -> database ID: ${actualSocietyId}`);
        // Look up machine
        const machineIdVariants = (machineValidation.variants || []).map((v)=>String(v));
        if (machineIdVariants.length === 0) {
            const machineIdCleaned = machineValidation.alphanumericId || machineValidation.numericId?.toString() || '';
            machineIdVariants.push(machineIdCleaned);
        }
        const placeholders = machineIdVariants.map(()=>'?').join(', ');
        const machineQuery = `
      SELECT id, machine_id 
      FROM \`${schemaName}\`.machines 
      WHERE society_id = ? AND machine_id IN (${placeholders})
      LIMIT 1
    `;
        const [machineResults] = await sequelize.query(machineQuery, {
            replacements: [
                actualSocietyId,
                ...machineIdVariants
            ]
        });
        if (!Array.isArray(machineResults) || machineResults.length === 0) {
            console.log(`âŒ Machine not found: "${collectionData.machineId}"`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Machine not found');
        }
        const actualMachine = machineResults[0];
        console.log(`âœ… Found machine: "${collectionData.machineId}" -> database ID: ${actualMachine.id}`);
        console.log(`â„¹ï¸  Farmer ID from input: "${collectionData.farmerId}"`);
        // Parse datetime: D2025-07-24_02:40:26 -> date: 2025-07-24, time: 02:40:26
        const datetimeParts = collectionData.datetime.split('_');
        const datePart = datetimeParts[0] || ''; // 2025-07-24
        const timePart = datetimeParts[1]?.replace(/-/g, ':') || '00:00:00'; // 02:40:26
        const formattedDate = datePart;
        const formattedTime = timePart;
        // Determine shift time (morning or evening)
        const shiftType = collectionData.session.toUpperCase() === 'EV' ? 'evening' : 'morning';
        // Use extra field as farmer name
        const farmerName = collectionData.extra || null;
        // Insert collection record
        const insertQuery = `
      INSERT INTO \`${schemaName}\`.milk_collections (
        farmer_id,
        society_id,
        machine_id,
        collection_date,
        collection_time,
        shift_type,
        farmer_name,
        channel,
        fat_percentage,
        snf_percentage,
        clr_value,
        protein_percentage,
        lactose_percentage,
        salt_percentage,
        water_percentage,
        temperature,
        quantity,
        rate_per_liter,
        total_amount,
        bonus,
        machine_type,
        machine_version,
        created_at,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CONVERT_TZ(NOW(), '+00:00', '+05:30'), CONVERT_TZ(NOW(), '+00:00', '+05:30'))
      ON DUPLICATE KEY UPDATE
        farmer_name = VALUES(farmer_name),
        channel = VALUES(channel),
        fat_percentage = VALUES(fat_percentage),
        snf_percentage = VALUES(snf_percentage),
        clr_value = VALUES(clr_value),
        protein_percentage = VALUES(protein_percentage),
        lactose_percentage = VALUES(lactose_percentage),
        salt_percentage = VALUES(salt_percentage),
        water_percentage = VALUES(water_percentage),
        temperature = VALUES(temperature),
        quantity = VALUES(quantity),
        rate_per_liter = VALUES(rate_per_liter),
        total_amount = VALUES(total_amount),
        bonus = VALUES(bonus),
        machine_type = VALUES(machine_type),
        machine_version = VALUES(machine_version),
        updated_at = CONVERT_TZ(NOW(), '+00:00', '+05:30')
    `;
        const insertParams = [
            collectionData.farmerId,
            actualSocietyId,
            actualMachine.id,
            formattedDate,
            formattedTime,
            shiftType,
            farmerName,
            collectionData.channel,
            collectionData.fat,
            collectionData.snf,
            collectionData.clr,
            collectionData.protein,
            collectionData.lactose,
            collectionData.salt,
            collectionData.water,
            collectionData.temperature,
            collectionData.quantity,
            collectionData.rate,
            collectionData.totalAmount,
            collectionData.bonus,
            collectionData.machineType,
            collectionData.version
        ];
        console.log(`ðŸ’¾ Saving collection record (will insert or update if duplicate)...`);
        console.log(`   Farmer ID: ${collectionData.farmerId}`);
        console.log(`   Farmer Name: ${farmerName}`);
        console.log(`   Date: ${formattedDate}`);
        console.log(`   Time: ${formattedTime}`);
        console.log(`   Shift: ${shiftType}`);
        console.log(`   Channel: ${collectionData.channel}`);
        console.log(`   Fat: ${collectionData.fat}%, SNF: ${collectionData.snf}%`);
        console.log(`   Quantity: ${collectionData.quantity}L, Rate: ${collectionData.rate}, Total: ${collectionData.totalAmount}, Bonus: ${collectionData.bonus}`);
        const queryResult = await sequelize.query(insertQuery, {
            replacements: insertParams
        });
        // Check if this was a new insert or an update
        // For Sequelize raw queries with INSERT...ON DUPLICATE KEY UPDATE:
        // - Returns array [lastInsertId, affectedRows]
        // - affectedRows = 1 means INSERT (new record)
        // - affectedRows = 2 means UPDATE (duplicate key, existing record updated)
        const [lastInsertId, affectedRows] = queryResult;
        console.log(`ðŸ“Š Query result - lastInsertId: ${lastInsertId}, affectedRows: ${affectedRows}`);
        const isNewCollection = affectedRows === 1;
        console.log(`âœ… Collection record saved successfully${isNewCollection ? ' (new collection)' : ' (duplicate updated)'}`);
        // Update section pulse tracking
        try {
            const collectionDateTime = `${formattedDate} ${formattedTime}`;
            await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sectionPulseTracker$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SectionPulseTracker"].updatePulseOnCollection(sequelize, schemaName, actualSocietyId, collectionDateTime, isNewCollection // Pass flag to indicate if this is a new collection
            );
            console.log(`âœ… Section pulse updated successfully`);
        } catch (pulseError) {
            // Log pulse tracking error but don't fail the collection save
            console.error(`âš ï¸ Failed to update section pulse:`, pulseError);
        }
        // Send email notification to farmer (if new collection and email exists)
        if (isNewCollection) {
            try {
                // Fetch farmer details including email and notification preference
                const farmerQuery = `
          SELECT f.name as farmer_name, f.email, f.email_notifications_enabled, s.name as society_name
          FROM \`${schemaName}\`.farmers f
          LEFT JOIN \`${schemaName}\`.societies s ON f.society_id = s.id
          WHERE f.farmer_id = ?
          LIMIT 1
        `;
                const [farmerResults] = await sequelize.query(farmerQuery, {
                    replacements: [
                        collectionData.farmerId
                    ]
                });
                if (Array.isArray(farmerResults) && farmerResults.length > 0) {
                    const farmerData = farmerResults[0];
                    console.log(`ðŸ“§ Email check for farmer ${collectionData.farmerId}:`, {
                        hasEmail: !!farmerData.email,
                        email: farmerData.email,
                        notificationSetting: farmerData.email_notifications_enabled,
                        willSend: farmerData.email && farmerData.email.trim() !== '' && farmerData.email_notifications_enabled === 'ON'
                    });
                    // Only send email if: (1) email exists, (2) notifications are enabled
                    if (farmerData.email && farmerData.email.trim() !== '' && farmerData.email_notifications_enabled === 'ON') {
                        console.log(`ðŸ“§ Sending collection email to farmer ${collectionData.farmerId} at ${farmerData.email}`);
                        // Import email service
                        const { sendMilkCollectionEmail } = await __turbopack_context__.A("[project]/src/lib/emailService.ts [app-route] (ecmascript, async loader)");
                        // Send email (don't await - send async)
                        sendMilkCollectionEmail(farmerData.email, farmerData.farmer_name || farmerName || collectionData.farmerId, {
                            farmerId: collectionData.farmerId,
                            societyName: farmerData.society_name,
                            collectionDate: formattedDate,
                            collectionTime: formattedTime,
                            shiftType: shiftType,
                            channel: collectionData.channel,
                            quantity: collectionData.quantity,
                            fatPercentage: collectionData.fat,
                            snfPercentage: collectionData.snf,
                            clrValue: collectionData.clr,
                            proteinPercentage: collectionData.protein,
                            lactosePercentage: collectionData.lactose,
                            waterPercentage: collectionData.water,
                            temperature: collectionData.temperature,
                            ratePerLiter: collectionData.rate,
                            totalAmount: collectionData.totalAmount,
                            bonus: collectionData.bonus
                        }).catch((emailError)=>{
                            // Log email error but don't fail the collection
                            console.error(`âš ï¸ Failed to send collection email:`, emailError);
                        });
                        console.log(`âœ… Collection email queued for sending`);
                    } else {
                        console.log(`â„¹ï¸  No email address found for farmer ${collectionData.farmerId}`);
                    }
                } else {
                    console.log(`â„¹ï¸  Farmer not found in database: ${collectionData.farmerId}`);
                }
            } catch (emailError) {
                // Log email error but don't fail the collection save
                console.error(`âš ï¸ Error processing collection email:`, emailError);
            }
        }
        console.log(`${'='.repeat(80)}\n`);
        // Return success response
        return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createResponse('Collection details saved successfully.', {
            addQuotes: true
        });
    } catch (error) {
        console.error(`âŒ Error in SaveCollectionDetails API:`, error);
        console.log(`${'='.repeat(80)}\n`);
        return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createErrorResponse('Failed to save collection details');
    }
}
const GET = handleRequest;
const POST = handleRequest;
async function OPTIONS() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$external$2d$api$2f$ESP32ResponseHelper$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ESP32ResponseHelper"].createCORSResponse();
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__08feb3e8._.js.map